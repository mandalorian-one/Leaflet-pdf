{"version":3,"file":"Leaflet.ImagePdf.umd.min.js","sources":["../src/js/covering.js","../src/js/Leaflet.ImagePdf.js","../src/js/image-processing.js"],"sourcesContent":["/**\n *      Leaflet.ImagePdf <https://github.com/mandalorian-one/Leaflet.ImagePdf>\n *\n *      MIT License http://www.opensource.org/licenses/mit-license.php\n *      Copyright (c) 2023  Alexander Cherviakov, <https://github.com/mandalorian-one/>\n *                          Northern Frontiers Pte Ltd, <https://northernfrontiers.com.fj/>\n *                          Herman Sletmoen, <https://github.com/hersle/leaflet-route-print>\n **/\n\n/**\n * areaRectanglesCount counts rectangles need to cover the area\n * @param tlc {L.Point} top left corner\n * @param brc {L.Point} top right corner\n * @param w {number} rectangle width\n * @param h {number} rectangle height\n */\nexport function areaRectanglesCount(tlc, brc, w, h) {\n    return [Math.ceil((brc.x - tlc.x) / w), Math.ceil((brc.y - tlc.y) / h)]\n}\n/**\n * coverAreaWithRectangles returns array of rectangles that cover the area\n * @param tlc {L.Point} top left corner\n * @param brc {L.Point} bottom right corner\n * @param w {number}  width in points\n * @param h {number}  height in points\n */\nexport function coverAreaWithRectangles(tlc, brc, w, h) {\n\n    let rects = []\n\n    let [wPages, hPages] = areaRectanglesCount(tlc, brc, w, h)\n    let startX = tlc.x\n    let startY = tlc.y\n\n    // cover area with rectangles\n    for (let i = 0; i < hPages; i++) {\n        for (let j = 0; j < wPages; j++) {\n            let x = startX + j * w\n            let y = startY + i * h\n            rects.push(new Rectangle(L.point(x, y), L.point(x + w, y + h)))\n        }\n    }\n    return rects\n}\n\n// coverLineWithRectangle and coverLineWithRectangles functions originally was written by Herman Sletmoen <https://github.com/hersle/leaflet-route-print>\n\nexport function coverLineWithRectangles(l, w, h, mix) {\n    let rects = [];\n    let intersections = [];\n    let i1 = 0;\n    while (true) {\n        let [rect, i2, intersection, dist] = coverLineWithRectangle(l, w, h, i1);\n        if (mix) {\n            let [recthw, i2hw, intersectionhw, disthw] = coverLineWithRectangle(l, h, w, i1);\n            rect.rotated = false;\n            if (disthw > dist) {\n                [rect, i2, intersection, dist] = [recthw, i2hw, intersectionhw, disthw];\n                rect.rotated = true;\n            }\n        }\n        rects.push(rect);\n        if (intersection === undefined) {\n            break;\n        }\n        intersections.push(intersection);\n        l.splice(i2, 0, intersection); // divide the segment TODO: don't modify input array\n        i1 = i2;\n    }\n    return [rects, intersections];\n}\n\nfunction coverLineWithRectangle(l, w, h, i1) {\n    let rect = new Rectangle(l[i1], l[i1]);\n    let segment;\n    let intersection = undefined;\n    let dist = 0;\n    let i = 0;\n    for (i = i1+1; i < l.length && intersection === undefined; i++) {\n        let grect = rect.extend(l[i]);\n        segment = new Segment(l[i-1], l[i]);\n        if (grect.isSmallerThan(w, h)) { // whole segment fits in rectangle [w,h]\n            rect = grect;\n        } else { // segment must be divided to fit in rectangle [w,h]\n            [rect, intersection] = rect.extendBounded(segment, w, h); // create rectangle as big as possible in the direction of the segment\n            segment = new Segment(l[i-1], intersection);\n        }\n        dist += segment.length();\n    }\n    rect = (new Rectangle(L.point(0, 0), L.point(w, h))).center(rect.middle);\n    return [rect, i, intersection, dist];\n}\n\nexport class Rectangle {\n    constructor(min, max) {\n        this.min = min;\n        this.max = max;\n    }\n\n    get xmin() { return this.min.x; }\n    get ymin() { return this.min.y; }\n    get xmax() { return this.max.x; }\n    get ymax() { return this.max.y; }\n\n    get corner1() { return L.point(this.xmin, this.ymin); }\n    get corner2() { return L.point(this.xmax, this.ymin); }\n    get corner3() { return L.point(this.xmax, this.ymax); }\n    get corner4() { return L.point(this.xmin, this.ymax); }\n    get topleft() { return this.corner1; }\n    get bottomright() { return this.corner3; }\n\n    get middle() { return this.min.add(this.max).divideBy(2); }\n\n    get size() { return this.max.subtract(this.min); }\n    get width() { return this.size.x; }\n    get height() { return this.size.y; }\n\n    center(c) {\n        let d = c.subtract(this.middle);\n        return new Rectangle(this.min.add(d), this.max.add(d));\n    }\n\n    extend(p) {\n        let min = L.point(Math.min(this.xmin, p.x), Math.min(this.ymin, p.y));\n        let max = L.point(Math.max(this.xmax, p.x), Math.max(this.ymax, p.y));\n        return new Rectangle(min, max);\n    }\n\n    extendToSquare() {\n        let d = Math.abs(this.size.x - this.size.y)\n        let offset = d / 2\n        let min = L.point(this.xmin, this.ymin)\n        let max = L.point(this.xmax, this.ymax)\n        if (this.size.x > this.size.y) {\n            min.y -= offset\n            max.y += offset\n        } else {\n            min.x -= offset\n            max.x += offset\n        }\n        return new Rectangle(min, max);\n    }\n\n    extendBounded(s, w, h) {\n        let d = s.displacement;\n        let maxRect;\n        if (d.x >= 0 && d.y >= 0) { // north-east quadrant\n            maxRect = new Rectangle(L.point(this.xmin, this.ymin), L.point(this.xmin+w, this.ymin+h));\n        } else if (d.x < 0 && d.y >= 0) { // north-west quadrant\n            maxRect = new Rectangle(L.point(this.xmax-w, this.ymin), L.point(this.xmax, this.ymin+h));\n        } else if (d.x < 0 && d.y < 0) { // south-west quadrant\n            maxRect = new Rectangle(L.point(this.xmax-w, this.ymax-h), L.point(this.xmax, this.ymax));\n        } else if (d.x > 0 && d.y < 0) { // south-east quadrant\n            maxRect = new Rectangle(L.point(this.xmin, this.ymax-h), L.point(this.xmin+w, this.ymax));\n        }\n        let intersection = maxRect.intersection(s);\n        console.assert(intersection !== undefined, \"segment-rectangle intersection test failed\");\n        return [this.extend(maxRect.intersection(s)), intersection];\n    }\n\n    pad(p) {\n        return new Rectangle(this.min.subtract(L.point(p, p)), this.max.add(L.point(p,p)));\n    }\n\n    scale(scale) {\n        return new Rectangle(this.min.multiplyBy(scale), this.max.multiplyBy(scale));\n    }\n\n    isSmallerThan(w, h) {\n        return this.size.x <= w && this.size.y <= h;\n    }\n\n    intersection(s) {\n        let s1 = new Segment(this.corner1, this.corner2);\n        let s2 = new Segment(this.corner2, this.corner3);\n        let s3 = new Segment(this.corner3, this.corner4);\n        let s4 = new Segment(this.corner4, this.corner1);\n        let ss = [s1, s2, s3, s4];\n        for (let side of ss) {\n            let p = s.intersection(side);\n            // don't register intersection if it is in the beginning corner (TODO: why not?)\n            if (p !== undefined && !(p.x == s1.p1.x && p.y == s1.p1.y)) {\n                return p; // intersect with a side\n            }\n        }\n        return undefined; // no intersection\n    }\n}\n\nclass Segment {\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n\n    get displacement() { return this.p2.subtract(this.p1); }\n\n    intersection(s2) {\n        // see https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line_segment\n        let s1 = this;\n        let x1 = s1.p1.x, y1 = s1.p1.y, x2 = s1.p2.x, y2 = s1.p2.y; // segment 1\n        let x3 = s2.p1.x, y3 = s2.p1.y, x4 = s2.p2.x, y4 = s2.p2.y; // segment 2\n        let d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);\n        let t = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / d;\n        let u = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / d;\n        if (d !== 0 && t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n            var x = x1 + t*(x2-x1);\n            var y = y1 + t*(y2-y1);\n            return L.point(x, y);\n        } else {\n            return undefined\n        }\n    }\n\n    length() {\n        let dx = this.p2.x - this.p1.x;\n        let dy = this.p2.y - this.p1.y;\n        return (dx**2 + dy**2)**0.5;\n    }\n}\n\n\n","/**\n *      Leaflet.ImagePdf <https://github.com/mandalorian-one/Leaflet.ImagePdf>\n *\n *      MIT License http://www.opensource.org/licenses/mit-license.php\n *      Copyright (c) 2023  Alexander Cherviakov, <https://github.com/mandalorian-one/>\n *                          Northern Frontiers Pte Ltd, <https://northernfrontiers.com.fj/>\n *\n **/\n\nimport \"jspdf\";\n//import * as htmlToImage from 'html-to-image';\nimport {\n    coverLineWithRectangles, coverAreaWithRectangles, areaRectanglesCount, Rectangle\n} from \"./covering.js\";\nimport {resizeImage} from \"./image-processing\";\nimport {changeDpiBlob, changeDpiDataUrl} from 'changedpi';\n\nconst DEBUG = false;\nconst PageOrientationPortrait = 0\nconst PageOrientationLandscape = 1\nconst PageOrientationAuto = 2\n\nconst StatusReady = 0\nconst StatusAtWork = 1\nconst StatusAborted = 2\n\nconst AlgCoverUnknown = 0\nconst AlgCoverArea = 1\nconst AlgCoverPath = 2\n\nexport const OpGenerateImage = \"image\"\nexport const OpCreatePage = \"page\"\nexport const OpLoadTiles = \"tile\"\n\nlet progressSplashScreenDefaultStyle = {width: \"100vw\", height: \"100vh\", background: \"white\", \"z-index\": 950, position: \"fixed\", top: \"0px\", left: \"0px\", \"justify-content\": \"center\", \"align-items\": \"center\"}\n\nL.Control.ImagePdf = L.Control.extend({\n    options: {\n        pageFormat: \"A4\",\n        pageOrientation: PageOrientationPortrait,\n        pageMargin: 10,         // pdf option, page margin in mm\n        areaPadding: 10,        // pdf option, add padding to the area in mm\n        pagingMethod: 'pages',  // pdf option, define paging method for multi-page pdf generation\n                                // (possible values 'pages' | 'scale'), it's better to use 'pages' because 'scale' method now is not properly tested\n        scale: 50000,           // pdf option, default starting scale for 'scale' paging method\n        pageCount: 1,           // pdf option, default pages count for 'pages' paging method\n        dpi: 300,               // pdf option, define max target images dpi, it defines how deep the map will be zoomed to create images\n                                // the resulting image dpi depends on available tiles images resolution and page size in mm\n                                // the better available dpi will be used\n                                // higher dpi value leads to downloading more tiles and greatly increase images generation time\n        maxZoom: null,          // define map maximum zoom level we can fall to load image tiles\n                                // if null it will be evaluated from map.getMaxZoom()\n                                // can be number, or function, that should return the number\n        outputFileName: \"map.pdf\", // can be with or without file extension\n        downloadOnFinish: false, // starts browser's file download process in order to save pdf file\n        tilesLoadingTimeout: 10000, // msec, timeout for tile loading on every page(image) generation\n        imageFormat: \"jpeg\",    // pdf and image option, 'jpeg' or 'png'\n        imagePixelRatio: 1,     // for generate images for retina screens. set to 2 or window.devicePixelRatio\n        showProgressSplashScreen: true,\n        progressSplashScreenStyle: progressSplashScreenDefaultStyle,\n        rectanglePreviewStyle: { // defines the style of area preview rectangle\n            stroke: true,\n            weight: 1,\n            opacity: 1,\n            color: \"gray\",\n            fillColor: \"gray\",\n            fillOpacity: 0.2\n        },\n        pdfFontSize: 15,            // default font size of text labels in pdf document\n        pdfPrintGraticule: true,    // isn;t implemented yet\n        pdfPrintScaleMeter: true,   // isn;t implemented yet\n        pdfSheetPageNumber: {       // add page number to a sheet at defined position\n            position: \"bottomright\",\n        },\n        pdfSheetAttribution: {      // add attribution text to a sheet at defined position\n            position: \"topleft\",\n            text: \"Created with Leaflet.ImagePdf\"\n        },\n        pdfDocumentProperties: {    // properties to add to the PDF document // name-to-value object structure\n            'creator': \"Leaflet.ImagePdf\"\n        },\n        excludeNodesWithCSS: ['div.leaflet-control-container', 'div.leaflet-control', 'div.pdf-progress-plug'], // exclude these dom nodes from the result images\n        pdfPageCb: null,        // callback function(pdf, pageNumber) that calls on every pdf page generation\n                                // you can use it to add you custom text or data to pdf pages (see jspdf spec on how to operate with pdf document)\n        nodeFilterCb: null,     // callback function(domNode) that calls on every dom element and should return true or false\n                                // in order to include or exclude element from images and pdf\n        debug: false,\n    },\n\n    initialize: function (map, options) {\n        if (options) {\n            L.setOptions(this, options)\n        }\n\n        this.options.progressSplashScreenStyle = Object.assign({}, progressSplashScreenDefaultStyle, this.options.progressSplashScreenStyle)\n\n        this.pixelRatio = this.options.imagePixelRatio || 1 // experimental, for HIDPI devices with retina screens and display scaling,\n                                                            // we need to generate images with correct DPI value written to the image\n        this.baseImageDpi = 72;\n        this.map = map;\n        this.area = null; //region to print, can contain any Leaflet object that has getBounds method\n\n        this.pageFormats = this.pageSizes()\n        this.pageOrientations = [\n            {name: \"Portrait\", value: PageOrientationPortrait},\n            {name: \"Landscape\", value: PageOrientationLandscape},\n            {name: \"Auto\", value: PageOrientationAuto},\n        ]\n        this.pageSize = {\n            width: 0,\n            height: 0,\n        }\n\n        this.status = StatusReady;\n        this.savedMapState = null;\n\n        this.pagesToPrint = [];\n\n        // keep all page rectangles in one group\n        this.rectGroup = L.layerGroup();\n\n        if (this.options.debug) {\n            this.debugRectGroup = L.layerGroup()\n            this.debugRectGroup.addTo(map)\n            this.debugRectStyle = {stroke: true, weight: 1, opacity: 0.8, color: \"green\", fillColor: \"green\", fillOpacity: 0.2};\n        }\n\n        //pdfDownloadOnFinish\n        this.downloadLink = document.createElement(\"a\")\n        Object.assign(this.downloadLink.style, {\"display\": \"none\"});\n\n        // css used on images generation stage\n        this.css = document.createElement(\"style\");\n        this.css.disabled = true\n        //this.css = new CSSStyleSheet() //isn't supported in safary yet\n        document.head.appendChild(this.css)\n        // prevent image opacity fade effect on tile load\n        this.css.sheet.insertRule('.leaflet-tile-container > img {opacity: 1 !important;}', 0);\n\n        this.progressDiv = document.createElement(\"div\")\n        Object.assign(this.progressDiv, {className: 'pdf-progress-plug'});\n        Object.assign(this.progressDiv.style, this.options.progressSplashScreenStyle,{display: \"none\"});\n        this.map._container.append(this.progressDiv)\n\n        this.setScale(this.options.scale)\n        this.setImageFormat(this.options.imageFormat);\n        this.setRectPreviewStyle(this.options.rectanglePreviewStyle)\n        this.setPageFormat(this.options.pageFormat)\n        this.setPageOrientation(this.options.pageOrientation)\n        this.setPageMargin(this.options.pageMargin)\n        this.setPagesToPrint([])\n        this.setPageCount(this.options.pageCount)\n    },\n\n    destroy: function () {\n        this.hideImageRegions()\n        this.map.removeLayer(this.rectGroup);\n        this.map._container.remove(this.progressDiv)\n    },\n\n    pageSizes: function() {\n        // list paper sizes from https://en.wikipedia.org/wiki/Paper_size#Overview_of_ISO_paper_sizes\n        let paperSizes = [];\n        let w = 0;\n        let h = 0;\n        for (let n = 0; n <= 6; n++) {\n            w = Math.floor(841  / 2**(n/2));\n            h = Math.floor(1189 / 2**(n/2));\n            paperSizes.push({name: `A${n}`, width: w, height: h});\n        }\n        for (let n = 0; n <= 6; n++) {\n            w = Math.floor(1000 / 2**(n/2));\n            h = Math.floor(1414 / 2**(n/2));\n            paperSizes.push({name: `B${n}`, width: w, height: h});\n        }\n        return paperSizes\n    },\n\n    /**\n     * Returns current page size based on page orientation\n     * @returns {{width: number, height: number}}\n     * @private\n     */\n    _orientedPageSize: function () {\n        let w = this.pageSize.width;\n        let h = this.pageSize.height;\n        if (this.pageOrientation === PageOrientationLandscape) { // swap width <-> height\n            let wtmp = w; w = h; h = wtmp;\n        }\n        return {width: w, height: h}\n    },\n\n    /**\n     *\n     * @returns {object}\n     * @private\n     */\n    _pageData: function (scale, wmmPaper, hmmPaper) {\n        let pd = {\n            sPaper: 1,\n            sWorld: (scale != null) ? scale : this.scale,\n            wmmPaper: wmmPaper,\n            hmmPaper: hmmPaper,\n            pmmPaper: this.pageMargin,\n            pmmArea: this.options.areaPadding,\n            regionCenter: this.area.getCenter(), //center of area\n            dimensionsAtCurrentZoom: {},\n            dimensions: {},\n            targetZoom: 0\n        }\n\n        let paperToWorld = pd.sPaper / pd.sWorld;\n        let worldToPaper = 1 / paperToWorld;\n        let wmmWorld = pd.wmmPaper * worldToPaper;\n        let hmmWorld = pd.hmmPaper * worldToPaper;\n        let pmmWorld = pd.pmmPaper * worldToPaper;\n        let pmmAreaWorld = pd.pmmArea * worldToPaper;\n\n        // page dimension in points at current map zoom level\n        let cd = {\n            wpx: this.metersToPixels(wmmWorld / 1000, pd.regionCenter),\n            hpx: this.metersToPixels(hmmWorld / 1000, pd.regionCenter),\n            // page margin\n            ppx: this.metersToPixels(pmmWorld / 1000, pd.regionCenter),\n            // area padding in points at current map zoom level\n            appx: this.metersToPixels(pmmAreaWorld / 1000, pd.regionCenter),\n            dpi: Math.round(this.scaleToDPI(pd.sWorld))\n        }\n        pd.dimensionsAtCurrentZoom = cd\n\n        pd.targetScale = this.options.dpi / cd.dpi\n\n        Object.assign(pd, this._calcTargetZoomAndScale(pd.targetScale, parseInt))\n        pd.dpi = pd.dimensionsAtCurrentZoom.dpi / pd.scaleToTargetZoom\n\n        pd.dimensions = {\n            wpx: Math.floor(cd.wpx / pd.scaleToTargetZoom),\n            hpx: Math.floor(cd.hpx / pd.scaleToTargetZoom),\n            // page margin\n            ppx: Math.floor(cd.ppx / pd.scaleToTargetZoom),\n            // area padding in points at current map zoom level\n            appx: Math.floor(cd.appx / pd.scaleToTargetZoom),\n            dpi: pd.dpi\n        }\n        return pd\n    },\n\n    computeScaleAccordingPageCount: function (pageCount = 1) {\n\n        pageCount *= 1\n        let pageSize = this._orientedPageSize()\n        let bounds = (this.area instanceof L.LatLngBounds) ? this.area : this.area.getBounds()\n        let topLeft = this.map.project(bounds.getNorthWest())\n        let bottomRight = this.map.project(bounds.getSouthEast())\n        let areaW = bottomRight.x - topLeft.x // area width in points\n        let areaH = bottomRight.y - topLeft.y\n        let pd = this._pageData(this.scale, pageSize.width, pageSize.height) // only several\n        // computes scale we need to use in order the area fits into one page\n        let onePagesScaleW = Math.ceil(pd.sPaper * (this.pixelsToMeters(areaW, pd.regionCenter)) * 1000 / (pd.wmmPaper - pd.pmmPaper * 2 - pd.pmmArea * 2))\n        let onePagesScaleH = Math.ceil(pd.sPaper * (this.pixelsToMeters(areaH, pd.regionCenter)) * 1000 / (pd.hmmPaper - pd.pmmPaper * 2 - pd.pmmArea * 2))\n        let onePagesScale = Math.max(onePagesScaleW, onePagesScaleH)\n\n        if (this.options.debug) {\n            // draw bounds area\n            let rect = [this.map.unproject(topLeft), this.map.unproject(bottomRight)];\n            L.rectangle(rect, this.debugRectStyle).addTo(this.debugRectGroup);\n        }\n\n        let algorithm = this._rectanglesEvaluationMethod(this.area)\n        let computePageCount = function (scale) {\n            return 0\n        }\n\n        // for route with one page covering returns the scale for route bounds\n        if (pageCount === 1 && algorithm === AlgCoverPath)\n            return onePagesScale\n\n        if (algorithm === AlgCoverArea) {\n            computePageCount = function (scale) {\n                let pd = this._pageData(scale, pageSize.width, pageSize.height).dimensionsAtCurrentZoom\n                let [rows, cols] = areaRectanglesCount(topLeft.subtract([pd.appx, pd.appx]), bottomRight.add([pd.appx, pd.appx]), pd.wpx - 2 * pd.ppx, pd.hpx - 2 * pd.ppx)\n                return rows * cols\n            }.bind(this)\n        } else if (algorithm === AlgCoverPath) {\n            computePageCount = function (scale) {\n                let pd = this._pageData(scale, pageSize.width, pageSize.height).dimensionsAtCurrentZoom\n                let rects = this._getRouteRectangles(this.area, pd.wpx, pd.hpx, pd.ppx, pd.appx, this.pageOrientation)\n                return rects.length\n            }.bind(this)\n        }\n\n        // sorts through the pages placements variants at different scale to get the better\n        // initially it was developed for paging along the route\n        // for rectangles it can be replaced with simple algorithm\n        let iterations = 0;\n        let scale = onePagesScale\n        let step = -scale / 2\n        let bestScale = 0\n        while (step > 10 || step < - 10) {\n            let switchDirection = false\n            iterations++\n            let c = computePageCount(scale)\n            if (c > pageCount) {\n                switchDirection = (step < 0)\n            } else if (c < pageCount) {\n                switchDirection = (step > 0)\n            } else {\n                bestScale = scale\n                step = Math.abs(step) * -1\n            }\n            // need to switch direction and decrease the step\n            if (switchDirection)\n                step = -step / 2\n            if (scale + step < 1) {\n                step = step / 2\n            }\n            scale = scale + step\n            if (iterations > 1000 || c === 0) {\n                console.error(\"something got wrong, to much iterations\")\n                break\n            }\n        }\n        if (bestScale > 0)\n            scale = bestScale\n        if (this.options.debug) {\n            console.log(`computeScale iterations: ${iterations}`)\n        }\n\n        return Math.ceil(scale)\n    },\n\n    _rectanglesEvaluationMethod: function (LObject) {\n        if ( LObject instanceof L.LatLngBounds ||\n             LObject instanceof L.Polygon ||\n            (LObject instanceof L.Polyline && this.isPagesPaging() && this.pageCount == 1)) {\n            return AlgCoverArea\n        } else if ( LObject instanceof L.Polyline) {\n            return AlgCoverPath\n        }\n        console.log(\"unknown geometry type\")\n        return AlgCoverUnknown\n    },\n\n    /**\n     * calcPdfPages computes pages data according current map state and pages/pdf settings\n     * @returns {object} pages data that is used to page generation\n     */\n    calcPdfPages: function () {\n        if (!this.area)\n            return null;\n\n        if (this.area instanceof L.Polyline && !this.area._map) {\n            // object is not added to the map (or removed)\n            return null;\n        }\n\n        if (this.options.debug) {\n            this.debugRectGroup.clearLayers();\n        }\n\n        let scale = this.scale\n        if (this.isPagesPaging()) {\n            scale = this.computeScaleAccordingPageCount(this.pageCount)\n        }\n\n        let pageSize = this._orientedPageSize()\n        let pd = this._pageData(scale, pageSize.width, pageSize.height)\n\n        pd.rectsAtCurrentZoom = []\n        pd.rects = []\n        pd.images = []\n\n        let algorithm = this._rectanglesEvaluationMethod(this.area)\n        let getRectangles =\n            (algorithm === AlgCoverArea) ? this._getBoxRectangles.bind(this) :\n                (algorithm === AlgCoverPath) ? this._getRouteRectangles.bind(this) :\n                function () {return []}\n\n        let dims = pd.dimensionsAtCurrentZoom\n        pd.rectsAtCurrentZoom = getRectangles(this.area, dims.wpx, dims.hpx, dims.ppx, dims.appx, this.pageOrientation)\n\n        // pad rectangles with margin and scale to printing zoom\n        for (let i = 0; i < pd.rectsAtCurrentZoom.length; i++) {\n            let rotated = pd.rectsAtCurrentZoom[i].rotated; // property is destroyed after padding\n            pd.rectsAtCurrentZoom[i] = pd.rectsAtCurrentZoom[i].pad(dims.ppx);\n            let scaledRect = pd.rectsAtCurrentZoom[i].scale(1/pd.scaleToTargetZoom);\n            pd.rectsAtCurrentZoom[i].rotated = rotated; // todo check, may be obsolete\n            scaledRect.rotated = rotated;\n            pd.rects.push(scaledRect);\n        }\n\n        pd.pageCount = pd.rects.length\n        pd.pagesToPrint = []\n\n        // prepare list of page numbers to print if pagesToPrintDefined\n        if (this.pagesToPrintDefined.length > 0) {\n            for (let p = 0; p < pd.rects.length; p++) {\n                if (this.pagesToPrintDefined.includes(p))\n                    pd.pagesToPrint.push(p);\n            }\n        } else {\n            for (let p = 0; p < pd.rects.length; p++) {\n                pd.pagesToPrint.push(p);\n            }\n        }\n\n        pd.pagesToPrintCount = pd.pagesToPrint.length\n        return pd\n    },\n\n    /**\n     * calc rectangles for image generation\n     * now supports only one rectangle\n     * @param targetSizePx\n     * @param paddingPx\n     * @param extendToSquare\n     * @returns {{dimensionsAtCurrentZoom: {hpx: number, aapx: number, wpx: number}, targetScale: number, targetZoom: number, rects: *[], rectsAtCurrentZoom: []}}\n     */\n    calcImages: function (targetSizePx, paddingPx, extendToSquare) {\n        if (!this.area)\n            return null;\n\n        if (this.area instanceof L.Polyline && !this.area._map) {\n            // if object is not added to the map (or removed)\n            return null;\n        }\n\n        let bounds = this.area instanceof L.LatLngBounds ? this.area : this.area.getBounds()\n\n        //todo create Rectangle object and perform some calculations using his methods\n        let areaRect = new Rectangle(this.map.project(bounds.getNorthWest()), this.map.project(bounds.getSouthEast()))\n\n        // scale from current zoom to target resolution\n        let targetScale = targetSizePx / Math.max(areaRect.width, areaRect.height)\n        let scaledPadding = paddingPx / targetScale\n\n        // extend area with padding\n        areaRect = areaRect.pad(scaledPadding)\n\n        if (extendToSquare)\n            areaRect = areaRect.extendToSquare()\n\n        let rects = coverAreaWithRectangles(areaRect.topleft, areaRect.bottomright, areaRect.width, areaRect.height)\n\n        if (rects.length !== 1) {\n            // only one rect is now supported\n            console.error(\"pdf:image:something got wrong with rectangle evaluation\")\n        }\n\n        let cd = {\n            wpx: areaRect.width,\n            hpx: areaRect.height,\n            aapx: paddingPx / targetScale // not impl\n        }\n\n        targetScale = targetSizePx / Math.max(cd.wpx, cd.hpx)\n        let imagesData = {\n            dimensionsAtCurrentZoom: cd,\n            targetScale: targetScale,\n            targetZoom: 0,\n            rectsAtCurrentZoom: rects,\n            rects: [],\n        }\n\n        Object.assign(imagesData, this._calcTargetZoomAndScale(targetScale))\n\n        // rescale rects to target zoom\n        for (let i = 0; i < imagesData.rectsAtCurrentZoom.length; i++) {\n            imagesData.rects[i] = imagesData.rectsAtCurrentZoom[i].scale(1/imagesData.scaleToTargetZoom)\n        }\n\n        imagesData.dimensions = {\n            wpx: Math.floor(cd.wpx / imagesData.scaleToTargetZoom),\n            hpx: Math.floor(cd.hpx / imagesData.scaleToTargetZoom),\n            // page margin\n            //ppx: Math.floor(cd.ppx / imagesData.scaleToTargetZoom),\n            // area padding in points at current map zoom level\n            appx: Math.floor(cd.appx / imagesData.scaleToTargetZoom),\n        }\n\n        // todo most of this calc also are used in pdf rectangles calculations\n        //      improvement: create 'RectField' class, where to move most of rectangles calculations\n        return imagesData\n    },\n\n    /**\n     * // _calcTargetZoomAndScale calculates target map zoom level and scale factor from current zoom to target zoom in order to get image at targetScale\n     * @param targetScale\n     * @param round\n     * @private\n     */\n    _calcTargetZoomAndScale: function (targetScale, round = Math.ceil) {\n        // with multiply tile layers map.getMaxZoom() returns maximum zoom from all layers\n        // but if the layer with maximum zoom level is filtered from output we will get\n        // an incorrect image at this target zoom, so we need to define maxMapZoom manually\n        let maxZoom = (this.maxZoom) ?\n            ((typeof this.maxZoom === \"function\") ? this.maxZoom() : this.maxZoom) :\n            this.map.getMaxZoom()\n\n        let targetZoom = Math.min(\n            maxZoom,\n            round(this.map.getScaleZoom(targetScale, this.map.getZoom()))\n        )\n        let scaleToTargetZoom = this.map.getZoomScale(this.map.getZoom(), targetZoom)\n\n        return {targetZoom: targetZoom, scaleToTargetZoom: scaleToTargetZoom}\n    },\n\n    /**\n     * showPdfPages shows pages preview rectangles on the map\n     * @returns {{hmmPaper, regionCenter: *, sWorld: (*|number), sPaper: number, pmmPaper: number, wmmPaper}}\n     */\n    showPdfPages: function (printData) {\n        if (this.area === null || this.status !== StatusReady) {\n            console.error(\"pdf: pdf creating is already in progress\")\n            return null\n        }\n\n        if (! printData)\n            printData = this.calcPdfPages()\n\n        if (printData) {\n            this._showRectangles(printData.rectsAtCurrentZoom, printData.dimensionsAtCurrentZoom.ppx)\n        } else {\n            this.hideImageRegions()\n        }\n        return printData\n    },\n\n    /**\n     * showImageRegions shows preview of image area rectangle on the map\n     * @param imageData\n     * @returns {null|*}\n     */\n    showImageRegions: function (imageData) {\n        if (this.area === null || this.status !== StatusReady) {\n            console.error(\"pdf: is already in progress\")\n            return null\n        }\n\n        if (! imageData) {\n            this.hideImageRegions()\n            return\n        }\n\n        this._showRectangles(imageData.rectsAtCurrentZoom, imageData.dimensionsAtCurrentZoom.aapx)\n\n        return imageData\n    },\n\n    /**\n     * hides pages preview rectangles on the map\n     */\n    hideImageRegions: function () {\n        this.rectGroup.clearLayers();\n    },\n\n    /**\n     * _lockMap locks the map and change map state for images generation\n     * @private\n     */\n    _lockMap: function() {\n        this.savedMapState = {\n            width: this.map.getContainer().style.width,\n            height: this.map.getContainer().style.height,\n            center: this.map.getCenter(),\n            zoom: this.map.getZoom(),\n            imageRectangles: !!(this.rectGroup._map),\n            containerOverflow: this.map._container.parentElement.style.overflow\n        }\n        // todo add rectGroup css selector to node filter, and we can avoid removing the layer\n        this.map.removeLayer(this.rectGroup);\n        if (this.options.debug) {\n            this.debugRectGroup.clearLayers()\n        }\n        if (this.options.showProgressSplashScreen) {\n            Object.assign(this.progressDiv.style, {\n                display: \"flex\",\n                height: window.visualViewport.height+'.px',\n                width: window.visualViewport.width+'.px',\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n            });\n            this.map._container.parentElement.style.overflow = \"hidden\" // hide scrollbars\n        }\n        this._disableInput();\n        this.css.disabled = false\n    },\n\n    /**\n     * _restoreMap restores the map after image generation\n     * @private\n     */\n    _restoreMap: function () {\n        this.map.getContainer().style.width = this.savedMapState.width;\n        this.map.getContainer().style.height = this.savedMapState.height;\n        this.map.setView(this.savedMapState.center, this.savedMapState.zoom, {animate: false})\n        if (this.savedMapState.imageRectangles) {\n            this.map.addLayer(this.rectGroup)\n        }\n        this.map._container.parentElement.style.overflow = this.savedMapState.containerOverflow\n        this.map.invalidateSize();\n        this.progressDiv.style.display = \"none\"\n        //this.map.addLayer(this.rectGroup);\n        this._enableInput();\n        this.css.disabled = true\n        this.status = StatusReady;\n    },\n\n    /**\n     * disables map controls and input\n     * @private\n     */\n    _disableInput: function() {\n        //console.log(\"input disabled\");\n        this.map.boxZoom.disable();\n        this.map.doubleClickZoom.disable();\n        this.map.dragging.disable();\n        this.map.keyboard.disable();\n        this.map.scrollWheelZoom.disable();\n        if (this.map.tapHold) this.map.tapHold.disable(); // specific to mobile Safari\n        this.map.touchZoom.disable();\n    },\n\n    /**\n     * restores map controls and input\n     * @private\n     */\n    _enableInput: function() {\n        //console.log(\"input enabled\");\n        this.map.boxZoom.enable();\n        this.map.doubleClickZoom.enable();\n        this.map.dragging.enable();\n        this.map.keyboard.enable();\n        this.map.scrollWheelZoom.enable();\n        if (this.map.tapHold) this.map.tapHold.enable(); // specific to mobile Safari\n        this.map.touchZoom.enable();\n    },\n\n    /**\n     * createPdf starts a background pdf creation process, the map will be locked.\n     * subscribe to events in order to control the progress and catch the results\n     * @returns {boolean} false if there are already running printing or something got wrong with\n     */\n    createPdf: function () {\n        if (this.status !== StatusReady) {\n            return false\n        }\n\n        let pagesData = this.calcPdfPages()\n\n        if (!pagesData)\n            return false\n\n        this.status = StatusAtWork\n        this.fireStarted(pagesData)\n        this._lockMap()\n        document.addEventListener(\"pdf:imagesCompleted\", this._createPdf.bind(this, pagesData), {once: true});\n\n        this._createImages(pagesData.rects, pagesData.pagesToPrint, pagesData.targetZoom, this.imageFormat);\n    },\n\n    /**\n     * createImage starts a background image creation process, the map will be locked.\n     * subscribe to events in order to control the progress and catch the results\n     * @param targetSizePx\n     * @param paddingPx\n     * @param extendToSquare\n     * @param performScaleToTargetSize\n     * @returns {boolean}\n     */\n    createImage: function (targetSizePx, paddingPx, extendToSquare, performScaleToTargetSize = true) {\n        if (this.status !== StatusReady) {\n            return false\n        }\n\n        let finish = function (blob) {\n            this._restoreMap();\n            this.fireFinish(blob)\n        }.bind(this)\n\n        let imagesData = this.calcImages(targetSizePx, paddingPx, extendToSquare)\n\n        if (!imagesData)\n            return false\n\n        let rect = imagesData.rects[0]\n        let resultWidth = targetSizePx\n        let resultHeight = targetSizePx\n        if (! extendToSquare) {\n            if (rect.width >= rect.height) {\n                resultHeight = Math.round(rect.height / (rect.width / targetSizePx))\n            } else {\n                resultWidth = Math.round(rect.width / (rect.height / targetSizePx))\n            }\n        }\n\n        this.status = StatusAtWork\n        this.fireStarted(imagesData)\n        this._lockMap()\n\n        document.addEventListener(\"pdf:imagesCompleted\", function (data) {\n            if (! data.detail || ! data.detail.images || data.detail.images.length === 0) {\n                finish()\n                return\n            }\n            if (! performScaleToTargetSize) {\n                this._startDownload(data.detail.images[0], this.imageFormat === 'jpeg' ? 'jpg' : this.imageFormat)\n                finish(data.detail.images[0])\n            } else {\n                // todo there are some possible improvement to reduce vector layers blur on rendered image resizing.\n                //      we can render vector layers separately at target scale and than mix them with raster layers\n                resizeImage(data.detail.images[0], resultWidth, resultHeight, 'image/'+this.imageFormat).then(function (imageUrl) {\n                        this._startDownload(imageUrl, this.imageFormat === 'jpeg' ? 'jpg' : this.imageFormat)\n                        finish(imageUrl)\n                    }.bind(this)\n                ).catch(function (er) {\n                    console.error(er)\n                    finish()\n                })\n            }\n        }.bind(this), {once: true});\n\n        this._createImages([rect], null, imagesData.targetZoom, performScaleToTargetSize ? 'blob' :this.imageFormat);\n\n    },\n    /**\n     * abort aborts a running pdf or image generation\n     */\n    abort: function () {\n        if (this.status !== StatusAtWork)\n            return\n\n        this.status = StatusAborted\n    },\n\n    /**\n     * _createPdf creates pdf and fire the finish event with data set to pdf blob on success or null on fail / abort\n     * don't call it directly\n     * @param {PagesData}\n     * @private\n     */\n    _createPdf(pd, data) {\n\n        let images = (data.detail) ? data.detail.images : []\n        let blob = null\n        let finish = function () {\n            this._restoreMap();\n            this.fireFinish(blob)\n        }.bind(this)\n\n        if (this.status === StatusAborted) {\n            finish()\n            return\n        }\n\n        if (!images || images.length !== pd.pagesToPrintCount) {\n            console.log(\"pdf: images count is not equal rects count\")\n            finish()\n        }\n\n        // todo add more intelligent text labels processing to except text overlapping\n        let addText = function (pdf, pageFormat, descriptor) {\n            if (!pdf || !descriptor || !descriptor.text || descriptor.text === \"\" || !descriptor.position)\n                return\n            let w = pageFormat[0]\n            let h = pageFormat[1]\n            let p = descriptor.position\n            let t = descriptor.text\n            let tw = 0\n            let th = 0\n            let attr = {}\n            if (p === \"topleft\") {\n                tw = 0+5; th = 0+5; attr = {align: \"left\", baseline: \"top\"}\n            } else if (p === \"topright\") {\n                tw = w-5; th = 0+5; attr = {align: \"right\", baseline: \"top\"}\n            } else if (p === \"bottomleft\") {\n                tw = 0+5; th = h-5; attr = {align: \"left\", baseline: \"bottom\"}\n            } else if (p === \"bottomright\") {\n                tw = w-5; th = h-5; attr = {align: \"right\", baseline: \"bottom\"}\n            } else {\n                console.warn(\"pdf: unknown text position\")\n                return\n            }\n            pdf.text(t, tw, th, attr);\n        }\n\n        let pdf = null;\n        for (let i = 0; i < pd.pagesToPrint.length; i++) {\n            let rect = pd.rects[pd.pagesToPrint[i]];\n            this.fireProgress(OpCreatePage, i, pd.pagesToPrint.length, rect)\n            let w, h;\n            // recognize rotated portrait/landscape rectangles\n            if (rect.rotated) {\n                w = pd.hmmPaper;\n                h = pd.wmmPaper;\n            } else {\n                w = pd.wmmPaper;\n                h = pd.hmmPaper;\n            }\n            let orientation = w > h ? \"landscape\" : \"portrait\";\n            try {\n                let pageFormat = [w, h]\n                if (pdf == null) {\n                    pdf = new jspdf.jsPDF({format: pageFormat, orientation: orientation, compress: true});\n                    pdf.setFontSize(this.options.pdfFontSize);\n                    if (this.options.pdfDocumentProperties !== null && Object.keys(this.options.pdfDocumentProperties).length > 0) {\n                        pdf.setDocumentProperties(this.options.pdfDocumentProperties)\n                    }\n                }  else {\n                    pdf.addPage([w, h], orientation);\n                }\n                pdf.addImage(images[i], this.imageFormat, 0, 0, w, h, undefined, \"FAST\");\n                addText(pdf, pageFormat, this.options.pdfSheetAttribution)\n                addText(pdf, pageFormat, Object.assign({text: `Page ${pd.pagesToPrint[i]+1} of ${pd.pageCount}`}, this.options.pdfSheetPageNumber))\n\n                if (this.options.pdfPageCb && typeof this.options.pdfPageCb === \"function\") {\n                    this.options.pdfPageCb(pdf, pd.pagesToPrint[i])\n                }\n                //pdf.text(`Scale ${pd.sPaper} : ${pd.sWorld}`, 0+5, h-5, {align: \"left\", baseline: \"bottom\"});\n                //let attrib = this._getAttribution();\n                //if (attrib) {\n                //    pdf.text(attrib, w-5, h-5, {align: \"right\", baseline: \"bottom\"});\n                //}\n            } catch (e) {\n                console.error(e)\n                this.status = StatusAborted\n                break\n            }\n        }\n        if (this.status === StatusAborted) {\n            finish()\n            return\n        }\n\n        blob = pdf.output(\"blob\", {filename: this._fixFileExt(this.options.outputFileName, 'pdf')});\n        this._startDownload(blob, 'pdf')\n        finish()\n    },\n\n    /**\n     * creates series of images in background\n     * subscribe to document event \"pdf:imagesCompleted\" to catch when it is finished\n     * @private\n     * @param rects {[Rectangle]} describes areas to imaging\n     * @param indexes {[numbers]} list of indexes in rects array\n     * @param targetZoom {number} defines map zoom level the Rectangle coordinates belong to\n     * @param imageFormat {string}\n     */\n    _createImages: function(rects, indexes, targetZoom, imageFormat) {\n\n        let images = []\n\n        if (!indexes) {\n            indexes = []\n            for (let i = 0; i < rects.length; i++) {\n                indexes.push(i)\n            }\n        }\n        let finish = function () {\n            document.removeEventListener(\"pdf:documentTilesLoaded\", generateImage)\n            document.removeEventListener(\"pdf:startNextImage\", prepareDocumentForImaging)\n            document.dispatchEvent(new CustomEvent(\"pdf:imagesCompleted\", {detail: {images: images}}));\n        }.bind(this)\n\n        // filter out from printing some elements (buttons, dialogs, etc)\n        let filter = function (nodeElement) {\n            //console.log(node.nodeName + \".\" + node.className)\n            if (nodeElement.matches)\n                for (let s of this.options.excludeNodesWithCSS) {\n                    if (nodeElement.matches(s))\n                        return false\n                }\n            if (this.options.nodeFilterCb && typeof this.options.nodeFilterCb === \"function\")\n                return this.options.nodeFilterCb(nodeElement)\n\n            return true\n        }.bind(this)\n\n        let imageGenerator = function () {\n            return new Promise( (resolve, reject) => {\n                reject(\"image generator isn't implemented\")\n            })\n        }\n\n        /**\n         * it's better to use html-to-image or alternate package, but\n         * html-to-image package has a bug with resulting image (only one tile image is displayed along all the map)\n         * need to investigate\n         */\n        if (imageFormat === \"jpeg\") {\n            imageGenerator = domtoimage.toJpeg\n        } else if (imageFormat === \"png\") {\n            imageGenerator = domtoimage.toPng\n        } else if (imageFormat === \"blob\") {\n            imageGenerator = domtoimage.toBlob\n        }\n\n        let generateImage = function (ev) {\n            let i = ev.detail.i\n            let r = rects[indexes[i]]\n            // we do scale to improve image quality of vector data rendering on retina screens\n            let scale = this.pixelRatio\n            let options = {\n                width: Math.round(r.width) * scale,\n                height: Math.round(r.height) * scale,\n                style: {\n                    transform: 'scale(' + scale + ')',\n                    transformOrigin: 'top left'\n                },\n                filter: filter\n            }\n\n            imageGenerator(this.map.getContainer(), options)\n                .then(function (data) {\n                    if (this.status === StatusAborted) {\n                        finish()\n                        return;\n                    }\n                    // if scale > 1 fix images DPI value to correct display on retina screens\n                    if (scale > 1 && data instanceof Blob) {\n                        changeDpiBlob(data, this.baseImageDpi * this.pixelRatio).then(function (data) {\n                            images.push(data)\n                            document.dispatchEvent(new CustomEvent(\"pdf:startNextImage\", {detail: {i:i+1}}))\n                        })\n                    } else if (scale > 1) {\n                        data = changeDpiDataUrl(data, this.baseImageDpi * this.pixelRatio);\n                    }\n                    images.push(data)\n                    document.dispatchEvent(new CustomEvent(\"pdf:startNextImage\", {detail: {i:i+1}}))\n                }.bind(this))\n                .catch(function (er) {\n                    console.error(\"_createImages:domtoimage: got error\", er)\n                    this.fireAborted(\"internal error\")\n                    this.status = StatusAborted\n                    finish()\n                }.bind(this));\n        }.bind(this)\n\n        let prepareDocumentForImaging = function(ev) {\n            try {\n                let i = ev.detail.i\n                let p = indexes[i];\n\n                if (i === indexes.length || this.status === StatusAborted) {\n                    finish()\n                    return;\n                }\n\n                let timestamp = new Date().getTime()\n                let r = rects[p];\n                this.fireProgress(OpGenerateImage, i, indexes.length, r)\n                let w = r.width;\n                let h = r.height;\n                let viewCenter = r.middle;\n\n                // when map is still not zoomed to target zoom (at the first image)\n                if (this.map.getZoom() !== targetZoom) {\n                    let scaleToTargetZoom = this.map.getZoomScale(this.map.getZoom(), targetZoom)\n                    let scaledRect = r.scale(scaleToTargetZoom);\n                    viewCenter = scaledRect.middle\n                }\n                viewCenter = this.map.unproject(viewCenter)\n\n                this.map.getContainer().style.width = `${Math.ceil(w)}px`;\n                this.map.getContainer().style.height = `${Math.ceil(h)}px`;\n                this.map.invalidateSize();\n                this.map.setView(viewCenter, targetZoom, {animate: false});\n\n                // todo here we can fix some styles in order to vector layers, markers and tooltips\n                //      looks better (not so small at high DPI resolution)\n\n                //need to wait the all tiles is loaded\n                let timer = setInterval(function () {\n                    if (this.status === StatusAborted) {\n                        clearInterval(timer);\n                        finish()\n                        return;\n                    }\n                    let [totalTiles, loadedTiles, loadingLayer] = this._loadedTiles(this.map)\n                    if (this.options.debug) {\n                        console.log(`tiles loaded: ${loadedTiles} from ${totalTiles}`)\n                    }\n                    this.fireProgress(OpLoadTiles, loadedTiles, totalTiles, null)\n                    if (totalTiles === loadedTiles) {\n                        clearInterval(timer);\n                        document.dispatchEvent(new CustomEvent(\"pdf:documentTilesLoaded\", {detail: {i:i}}))\n                        return\n                    }\n                    if (new Date().getTime() - timestamp > this.options.tilesLoadingTimeout) {\n                        if (this.options.debug) {\n                            console.log(`Aborted due to tiles loading timeout of the layer: ${loadingLayer._url}`)\n                        }\n                        this.status = StatusAborted\n                        this.fireAborted(\"timeout\", loadingLayer)\n                        clearInterval(timer);\n                        finish()\n                    }\n                }.bind(this), 200);\n            } catch (e) {\n                console.error(\"prepareDocumentForImaging: got error\", e)\n                this.fireAborted(\"internal error\")\n                finish()\n            }\n        }.bind(this);\n\n        document.addEventListener(\"pdf:documentTilesLoaded\", generateImage);\n        document.addEventListener(\"pdf:startNextImage\", prepareDocumentForImaging);\n        document.dispatchEvent(new CustomEvent(\"pdf:startNextImage\", {detail: {i:0}}))\n    },\n\n    /**\n     * _loadedTiles check a raster map loading process and returns array with current state of the map\n     *\n     * @param map\n     * @returns {number[]}\n     * @private\n     */\n    _loadedTiles: function(map){\n        let totalTiles = 0\n        let loadedTiles = 0\n        let stillLoadingLayer = null\n        for (let l in map._layers) {\n            let layer = map._layers[l];\n            if (layer._url || layer._mutant) {\n                if (layer._level) {\n                    totalTiles += layer._level.el.childNodes.length\n                    loadedTiles += layer._level.el.querySelectorAll(\"img.leaflet-tile-loaded\").length\n                }\n                if (layer._loading && stillLoadingLayer === null) {\n                    stillLoadingLayer = layer\n                }\n            }\n        }\n        if (!stillLoadingLayer) {\n            loadedTiles = totalTiles\n        }\n        return [totalTiles, loadedTiles, stillLoadingLayer];\n    },\n\n    fireEvent: function (name, data) {\n        this.map.fire(\"imagePdf:\"+ name, data)\n    },\n\n    fireStarted: function (data) {\n        this.fireEvent(\"start\", data)\n    },\n\n    fireFinish: function (blob) {\n        this.fireEvent(\"finish\", {blob: blob})\n    },\n\n    fireProgress: function (operation, itemNo, totalItems, item) {\n        this.fireEvent(\"progress\", {operation: operation, itemNo: itemNo, totalItems: totalItems, item: item})\n    },\n\n    fireAborted: function (reason, data) {\n        this.fireEvent(\"aborted\", {reason: reason, data: data})\n    },\n\n    // temporary disabled\n    // todo need to refactored\n    _getAttribution: function() {\n        let attrib = undefined;\n        this.map.eachLayer(function(layer) {\n            if (attrib === undefined && layer.getAttribution()) {\n                attrib = layer.getAttribution().replace(/<[^>]*>/g, \"\");\n            }\n        });\n        return attrib;\n    },\n\n    pixelsToMeters: function(pixels, pos) {\n        // https://stackoverflow.com/questions/49122416/use-value-from-scale-bar-on-a-leaflet-map\n        let point1 = this.map.latLngToLayerPoint(pos).add(L.point(-pixels/2, 0));\n        let point2 = this.map.latLngToLayerPoint(pos).add(L.point(+pixels/2, 0));\n        point1 = this.map.layerPointToLatLng(point1);\n        point2 = this.map.layerPointToLatLng(point2);\n        return point1.distanceTo(point2);\n    },\n\n    metersToPixels: function(meters, pos) {\n        return meters / this.pixelsToMeters(1, pos);\n    },\n\n    scaleToDPI: function(scale) {\n        let sPaper = 1;\n        let sWorld = scale;\n\n        let size = this._orientedPageSize()\n        let wmmPaper = size.width;\n        let hmmPaper = size.height;\n        let paperToWorld = sPaper / sWorld;\n        let worldToPaper = 1 / paperToWorld;\n        let wmmWorld = wmmPaper * worldToPaper;\n        let hmmWorld = hmmPaper * worldToPaper;\n\n        let routeCenter = this.area.getCenter();\n        let wpxWorld = this.metersToPixels(wmmWorld / 1000, routeCenter);\n        let hpxWorld = this.metersToPixels(hmmWorld / 1000, routeCenter);\n\n        let dpix = wpxWorld / (wmmPaper / 25.4);\n        let dpiy = hpxWorld / (hmmPaper / 25.4);\n        let dpi = (dpix + dpiy) / 2;\n        return dpi;\n    },\n\n    DPIToScale: function(dpi) {\n        let size = this._orientedPageSize()\n        let wmmPaper = size.width;\n        let hmmPaper = size.height;\n        let wpxWorld = dpi / 25.4 * wmmPaper;\n        let hpxWorld = (hmmPaper / wmmPaper) * wpxWorld;\n        let sWorldx = 1 * this.pixelsToMeters(wpxWorld, this.area.getCenter()) * 1000 / wmmPaper;\n        let sWorldy = 1 * this.pixelsToMeters(hpxWorld, this.area.getCenter()) * 1000 / hmmPaper;\n        let sWorld = (sWorldx + sWorldy) / 2;\n        return sWorld;\n    },\n\n    _showRectangles: function (rects, p) {\n        this.rectGroup.clearLayers();\n        for (let i = 0; i < rects.length; i++) {\n            let bigRect = rects[i];\n            let smallRect = bigRect.pad(-p);\n\n            smallRect = [this.map.unproject(smallRect.min), this.map.unproject(smallRect.max)];\n            bigRect = [this.map.unproject(bigRect.min), this.map.unproject(bigRect.max)];\n\n            L.rectangle(bigRect,\n                Object.assign({}, this.rectPreviewStyle)).addTo(this.rectGroup);\n\n            L.rectangle(smallRect,\n                Object.assign({}, this.rectPreviewStyle, {fill: false})).addTo(this.rectGroup);\n        }\n        if (this.rectGroup._map == null) {\n            this.rectGroup.addTo(this.map);\n        }\n    },\n\n    _getBoxRectangles: function (LObject, w, h, p, areaPadding, o) {\n        if (LObject === null)\n            return []\n\n        let bounds = null\n\n        if ( LObject instanceof L.LatLngBounds)\n            bounds = LObject\n\n        if ( typeof LObject.getBounds == \"function\" )\n            bounds = LObject.getBounds()\n\n        if (!bounds)\n            return []\n\n        let topLeft = this.map.project(bounds.getNorthWest()).subtract([areaPadding,areaPadding])\n        let bottomRight = this.map.project(bounds.getSouthEast()).add([areaPadding,areaPadding])\n\n        const rects = coverAreaWithRectangles(topLeft, bottomRight, w-2*p, h-2*p)\n\n        return rects\n    },\n\n    _getRouteRectangles: function(LObject, w, h, p, ap, o) {\n        if (LObject === null || typeof LObject.getLatLngs !== \"function\")\n            return []\n\n        let ll = LObject.getLatLngs()\n\n        if (ll.length === 0) {\n            return [];\n        }\n\n        if (ll[0] instanceof Array) {\n            // multidimensional array (possible multipath ? )\n            // we will get only first path\n            ll = ll[0]\n        }\n        let l = ll.slice(); // copy array (algorithm will modify it) TODO: don't modify\n        for (let i = 0; i < l.length; i++) {\n            l[i] = this.map.project(l[i]); // geo to pixel coords (so paper size becomes meaningful)\n        }\n        const [rects, intersections] = coverLineWithRectangles(l, w-2*p, h-2*p, o === PageOrientationAuto);\n\n        // show intersection points (only for debugging purposes)\n        if (this.options.debug) {\n            // convert from pixel coordinates back to geographical coordinates\n            for (let i = 0; i < intersections.length; i++) {\n                intersections[i] = this.map.unproject(intersections[i]);\n            }\n\n            for (const p of intersections) {\n                L.circleMarker(p, {radius: 5, stroke: false, color: \"black\", opacity: 1, fillOpacity: 1.0}).addTo(this.debugRectGroup);\n            }\n        }\n\n        return rects;\n    },\n\n    _fixFileExt(filename, ext) {\n        let exts = ['jpg', 'png', 'pdf']\n        let i\n        let e\n        for (e of exts) {\n            let suffix = '.' + e\n            i = filename.lastIndexOf(suffix)\n            if (i !== -1) {\n                if (i === filename.length - suffix.length) {\n                    break\n                } else {\n                    i = -1\n                }\n            }\n        }\n        //fix extension\n        if (i !== -1) {\n            if (e === ext) {\n                return filename\n            } else {\n                return filename.substring(0, i) + '.' + ext\n            }\n        }\n        return filename + '.' + ext\n    },\n\n    _startDownload(data, ext) {\n        if (! this.options.downloadOnFinish || ! data)\n            return\n\n        // fix extensions if needed\n        let fileName = this._fixFileExt(this.options.outputFileName, ext)\n\n        Object.assign(this.downloadLink, {\"download\": fileName});\n        this.downloadLink.href = (data instanceof Blob) ? URL.createObjectURL(data) : data\n        this.downloadLink.click(); // download\n    },\n\n    isScalePaging() {\n        return this.options.pagingMethod === \"scale\"\n    },\n\n    isPagesPaging() {\n        return this.options.pagingMethod === \"pages\"\n    },\n\n    /**\n     * set the maximum zoom level of the map we can fall down for image tiles loading\n     * if null it will be evaluated from map.getMaxZoom()\n     * can be number, or function, that should return the number\n     * @param v\n     */\n    setMaxZoom: function (v) {\n        this.maxZoom = v\n    },\n\n    setArea: function (area) {\n        if (typeof area === 'object') {\n            if (! (area instanceof L.LatLngBounds) && typeof area.getBounds !== 'function') {\n                throw new Error(\"the area should be instance of LatLngBounds class, or must have getBounds method\")\n            }\n        }\n        this.area = area\n        if (!area) {\n            this.hideImageRegions()\n        }\n    },\n\n    setScale: function(scale) {\n        this.scale = parseInt(scale)\n    },\n\n    getScale: function() {\n        return this.scale\n    },\n\n    /**\n     * setPageCount defines the number of pages the area will be divided into\n     * used only if pagingMethod set to 'pages'\n     * @param pages\n     */\n    setPageCount: function (pages = 1) {\n        if (pages * 1 === 0)\n            pages = 1\n        this.pageCount = pages\n    },\n\n    /**\n     *\n     * @returns {number}\n     */\n    getPageCount: function () {\n        return this.pageCount\n    },\n    /**\n     * setPageOrientation defines pdf page orientation\n     * @param orientation\n     */\n    setPageOrientation: function (orientation) {\n        for (let o of this.pageOrientations) {\n            if (typeof orientation.toLowerCase === 'function' &&\n                o.name.toLowerCase() === orientation.toLowerCase()) {\n                this.pageOrientation = o.value\n                return\n            }\n            if (o.value === orientation) {\n                this.pageOrientation = orientation\n                return\n            }\n        }\n        //default page orientation\n        this.pageOrientation = this.options.pageOrientation\n    },\n\n    /**\n     * setPageMargin defines pdf page margin in mm\n     * @param mm\n     */\n    setPageMargin: function (mm) {\n        this.pageMargin = parseInt(mm)\n    },\n\n    getPageMargin: function () {\n        return this.pageMargin\n    },\n\n    /**\n     * setPagesToPrint defines page numbers to include into pdf document\n     * @param pagesNumbers\n     */\n    setPagesToPrint: function (pagesNumbers) {\n        if (typeof pagesNumbers !== 'object') {\n            this.pagesToPrintDefined = []\n        } else {\n            this.pagesToPrintDefined = pagesNumbers.slice()\n        }\n    },\n\n    /**\n     * setPageFormat defines page format\n     * @param name\n     */\n    setPageFormat: function (name) {\n        let i = this.pageFormats.findIndex(size => size.name === name)\n        if (i === -1) {\n            i = this.pageFormats.findIndex(size => size.name === this.options.pageFormat)\n        }\n        this.pageFormat = this.pageFormats[i];\n        this.pageSize.width = this.pageFormat.width\n        this.pageSize.height = this.pageFormat.height\n    },\n\n    setPageSize: function (width, height) {\n        if ((width > 0) && (height > 0)) {\n            this.pageSize.width = parseInt(width)\n            this.pageSize.height = parseInt(height)\n            this.pageFormat = null\n        }\n    },\n\n    getPageFormats: function () {\n      return this.pageFormats\n    },\n\n    getPageFormat: function () {\n        return this.pageFormat\n    },\n\n    getPageOrientations: function () {\n        return this.pageOrientations\n    },\n\n    setImageFormat: function(format) {\n        if (format != \"jpeg\" && format != \"png\") {\n            throw `Invalid image format: \"${format}\"`;\n        }\n        this.imageFormat = format;\n    },\n\n    setRectPreviewStyle: function (style) {\n        if (!style) {\n            style = this.options.rectanglePreviewStyle\n        }\n        this.rectPreviewStyle = Object.assign({}, style)\n    },\n})\n\n/**\n *\n * @param map\n * @param options\n * @returns {L.Control.ImagePdf}\n */\nL.imagePdf = function (map, options) {\n    return new L.Control.ImagePdf(map, options);\n};","/**\n *      Leaflet.ImagePdf <https://github.com/mandalorian-one/Leaflet.ImagePdf>\n *\n *      MIT License http://www.opensource.org/licenses/mit-license.php\n *      Copyright (c) 2023  Alexander Cherviakov, <https://github.com/mandalorian-one/>\n *                          Northern Frontiers Pte Ltd, <https://northernfrontiers.com.fj/>\n *\n **/\n\n/**\n * resizeImage resizes an image to a new size and returns promise with result of canvas.toDataURL\n * @param imageBlob\n * @param newWidth\n * @param newHeight\n * @param targetMimeType\n * @returns {Promise<unknown>}\n */\nexport function resizeImage(imageBlob, newWidth, newHeight, targetMimeType) {\n    return new Promise((resolve, reject) => {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n\n        createImageBitmap(imageBlob, {resizeWidth: newWidth, resizeHeight: newHeight, resizeQuality: \"high\"})\n            .then(imageBitmap => {\n                ctx.drawImage(imageBitmap, 0, 0)\n                resolve(canvas.toDataURL(targetMimeType,  0.9))\n            }).catch( function (er) {\n                reject(er)\n            })\n    });\n}\n\n"],"names":["areaRectanglesCount","tlc","brc","w","h","Math","ceil","x","y","coverAreaWithRectangles","rects","_areaRectanglesCount2","_slicedToArray","wPages","hPages","startX","startY","i","j","push","Rectangle","L","point","coverLineWithRectangle","l","i1","segment","rect","intersection","undefined","dist","length","grect","extend","Segment","isSmallerThan","_rect$extendBounded2","extendBounded","center","middle","min","max","_classCallCheck","this","_createClass","key","get","xmin","ymin","xmax","ymax","corner1","corner3","add","divideBy","subtract","size","value","c","d","p","offset","abs","s","maxRect","displacement","console","assert","scale","multiplyBy","s1","corner2","_i","_ss","corner4","side","p1","p2","s2","x1","y1","x2","y2","x3","y3","x4","y4","t","u","dx","dy","pow","OpGenerateImage","OpCreatePage","OpLoadTiles","progressSplashScreenDefaultStyle","width","height","background","position","top","left","Control","ImagePdf","options","pageFormat","pageOrientation","pageMargin","areaPadding","pagingMethod","pageCount","dpi","maxZoom","outputFileName","downloadOnFinish","tilesLoadingTimeout","imageFormat","imagePixelRatio","showProgressSplashScreen","progressSplashScreenStyle","rectanglePreviewStyle","stroke","weight","opacity","color","fillColor","fillOpacity","pdfFontSize","pdfPrintGraticule","pdfPrintScaleMeter","pdfSheetPageNumber","pdfSheetAttribution","text","pdfDocumentProperties","creator","excludeNodesWithCSS","pdfPageCb","nodeFilterCb","debug","initialize","map","setOptions","Object","assign","pixelRatio","baseImageDpi","area","pageFormats","pageSizes","pageOrientations","name","pageSize","status","savedMapState","pagesToPrint","rectGroup","layerGroup","debugRectGroup","addTo","debugRectStyle","downloadLink","document","createElement","style","display","css","disabled","head","appendChild","sheet","insertRule","progressDiv","className","_container","append","setScale","setImageFormat","setRectPreviewStyle","setPageFormat","setPageOrientation","setPageMargin","setPagesToPrint","setPageCount","destroy","hideImageRegions","removeLayer","remove","paperSizes","n","floor","concat","_orientedPageSize","wtmp","_pageData","wmmPaper","hmmPaper","pd","sPaper","sWorld","pmmPaper","pmmArea","regionCenter","getCenter","dimensionsAtCurrentZoom","dimensions","targetZoom","worldToPaper","wmmWorld","hmmWorld","pmmWorld","pmmAreaWorld","cd","wpx","metersToPixels","hpx","ppx","appx","round","scaleToDPI","targetScale","_calcTargetZoomAndScale","parseInt","scaleToTargetZoom","computeScaleAccordingPageCount","arguments","bounds","LatLngBounds","getBounds","topLeft","project","getNorthWest","bottomRight","getSouthEast","areaW","areaH","onePagesScaleW","pixelsToMeters","onePagesScaleH","onePagesScale","unproject","rectangle","algorithm","_rectanglesEvaluationMethod","computePageCount","bind","_getRouteRectangles","iterations","step","bestScale","switchDirection","error","log","LObject","Polygon","Polyline","isPagesPaging","calcPdfPages","_map","clearLayers","rectsAtCurrentZoom","images","getRectangles","_getBoxRectangles","dims","rotated","pad","scaledRect","pagesToPrintDefined","includes","pagesToPrintCount","calcImages","targetSizePx","paddingPx","extendToSquare","areaRect","scaledPadding","topleft","bottomright","aapx","imagesData","getMaxZoom","getScaleZoom","getZoom","getZoomScale","showPdfPages","printData","_showRectangles","showImageRegions","imageData","_lockMap","getContainer","zoom","imageRectangles","containerOverflow","parentElement","overflow","window","visualViewport","_disableInput","_restoreMap","setView","animate","addLayer","invalidateSize","_enableInput","boxZoom","disable","doubleClickZoom","dragging","keyboard","scrollWheelZoom","tapHold","touchZoom","enable","createPdf","pagesData","fireStarted","addEventListener","_createPdf","once","_createImages","createImage","performScaleToTargetSize","finish","blob","fireFinish","resultWidth","resultHeight","data","imageBlob","newWidth","newHeight","targetMimeType","detail","Promise","resolve","reject","canvas","ctx","getContext","createImageBitmap","resizeWidth","resizeHeight","resizeQuality","then","imageBitmap","drawImage","toDataURL","er","imageUrl","_startDownload","abort","addText","pdf","descriptor","tw","th","attr","align","baseline","warn","fireProgress","orientation","jspdf","jsPDF","format","compress","setFontSize","keys","setDocumentProperties","addPage","addImage","e","output","filename","_fixFileExt","indexes","removeEventListener","generateImage","prepareDocumentForImaging","dispatchEvent","CustomEvent","filter","nodeElement","matches","_step","_iterator","_createForOfIteratorHelper","done","err","f","imageGenerator","domtoimage","toJpeg","toPng","toBlob","ev","r","transform","transformOrigin","Blob","changeDpiBlob","changeDpiDataUrl","fireAborted","timestamp","Date","getTime","viewCenter","timer","setInterval","clearInterval","_this$_loadedTiles2","_loadedTiles","totalTiles","loadedTiles","loadingLayer","_url","stillLoadingLayer","_layers","layer","_mutant","_level","el","childNodes","querySelectorAll","_loading","fireEvent","fire","operation","itemNo","totalItems","item","reason","_getAttribution","attrib","eachLayer","getAttribution","replace","pixels","pos","point1","latLngToLayerPoint","point2","layerPointToLatLng","distanceTo","meters","routeCenter","DPIToScale","wpxWorld","hpxWorld","bigRect","smallRect","rectPreviewStyle","fill","o","ap","getLatLngs","ll","Array","slice","_coverLineWithRectang","mix","intersections","_coverLineWithRectang2","i2","_coverLineWithRectang4","recthw","i2hw","intersectionhw","disthw","splice","coverLineWithRectangles","_step2","_iterator2","circleMarker","radius","ext","_i3","_exts","suffix","lastIndexOf","substring","fileName","download","href","URL","createObjectURL","click","isScalePaging","setMaxZoom","v","setArea","_typeof","Error","getScale","pages","getPageCount","_step3","_iterator3","toLowerCase","mm","getPageMargin","pagesNumbers","_this","findIndex","setPageSize","getPageFormats","getPageFormat","getPageOrientations","imagePdf"],"mappings":"uzFAgBO,SAASA,EAAoBC,EAAKC,EAAKC,EAAGC,GAC7C,MAAO,CAACC,KAAKC,MAAMJ,EAAIK,EAAIN,EAAIM,GAAKJ,GAAIE,KAAKC,MAAMJ,EAAIM,EAAIP,EAAIO,GAAKJ,GACxE,CAQO,SAASK,EAAwBR,EAAKC,EAAKC,EAAGC,GASjD,IAPA,IAAIM,EAAQ,GAE8CC,EAAAC,EAAnCZ,EAAoBC,EAAKC,EAAKC,EAAGC,GAAE,GAArDS,EAAMF,EAAA,GAAEG,EAAMH,EAAA,GACfI,EAASd,EAAIM,EACbS,EAASf,EAAIO,EAGRS,EAAI,EAAGA,EAAIH,EAAQG,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAQK,IAAK,CAC7B,IAAIX,EAAIQ,EAASG,EAAIf,EACjBK,EAAIQ,EAASC,EAAIb,EACrBM,EAAMS,KAAK,IAAIC,EAAUC,EAAEC,MAAMf,EAAGC,GAAIa,EAAEC,MAAMf,EAAIJ,EAAGK,EAAIJ,IAC/D,CAEJ,OAAOM,CACX,CA6BA,SAASa,EAAuBC,EAAGrB,EAAGC,EAAGqB,GACrC,IACIC,EADAC,EAAO,IAAIP,EAAUI,EAAEC,GAAKD,EAAEC,IAE9BG,OAAeC,EACfC,EAAO,EACPb,EAAI,EACR,IAAKA,EAAIQ,EAAG,EAAGR,EAAIO,EAAEO,aAA2BF,IAAjBD,EAA4BX,IAAK,CAC5D,IAAIe,EAAQL,EAAKM,OAAOT,EAAEP,IAE1B,GADAS,EAAU,IAAIQ,EAAQV,EAAEP,EAAE,GAAIO,EAAEP,IAC5Be,EAAMG,cAAchC,EAAGC,GACvBuB,EAAOK,MACJ,CACuD,IAAFI,EAAAxB,EAAjCe,EAAKU,cAAcX,EAASvB,EAAGC,GAAE,GAAvDuB,EAAIS,EAAA,GAAER,EAAYQ,EAAA,GACnBV,EAAU,IAAIQ,EAAQV,EAAEP,EAAE,GAAIW,EAClC,CACAE,GAAQJ,EAAQK,QACpB,CAEA,MAAO,CADPJ,EAAQ,IAAIP,EAAUC,EAAEC,MAAM,EAAG,GAAID,EAAEC,MAAMnB,EAAGC,IAAKkC,OAAOX,EAAKY,QACnDtB,EAAGW,EAAcE,EACnC,CAEA,IAAaV,EAAS,WAClB,SAAAA,EAAYoB,EAAKC,GAAKC,OAAAtB,GAClBuB,KAAKH,IAAMA,EACXG,KAAKF,IAAMA,CACf,CAAC,OAAAG,EAAAxB,EAAA,CAAA,CAAAyB,IAAA,OAAAC,IAED,WAAa,OAAOH,KAAKH,IAAIjC,CAAG,GAAC,CAAAsC,IAAA,OAAAC,IACjC,WAAa,OAAOH,KAAKH,IAAIhC,CAAG,GAAC,CAAAqC,IAAA,OAAAC,IACjC,WAAa,OAAOH,KAAKF,IAAIlC,CAAG,GAAC,CAAAsC,IAAA,OAAAC,IACjC,WAAa,OAAOH,KAAKF,IAAIjC,CAAG,GAAC,CAAAqC,IAAA,UAAAC,IAEjC,WAAgB,OAAOzB,EAAEC,MAAMqB,KAAKI,KAAMJ,KAAKK,KAAO,GAAC,CAAAH,IAAA,UAAAC,IACvD,WAAgB,OAAOzB,EAAEC,MAAMqB,KAAKM,KAAMN,KAAKK,KAAO,GAAC,CAAAH,IAAA,UAAAC,IACvD,WAAgB,OAAOzB,EAAEC,MAAMqB,KAAKM,KAAMN,KAAKO,KAAO,GAAC,CAAAL,IAAA,UAAAC,IACvD,WAAgB,OAAOzB,EAAEC,MAAMqB,KAAKI,KAAMJ,KAAKO,KAAO,GAAC,CAAAL,IAAA,UAAAC,IACvD,WAAgB,OAAOH,KAAKQ,OAAS,GAAC,CAAAN,IAAA,cAAAC,IACtC,WAAoB,OAAOH,KAAKS,OAAS,GAAC,CAAAP,IAAA,SAAAC,IAE1C,WAAe,OAAOH,KAAKH,IAAIa,IAAIV,KAAKF,KAAKa,SAAS,EAAI,GAAC,CAAAT,IAAA,OAAAC,IAE3D,WAAa,OAAOH,KAAKF,IAAIc,SAASZ,KAAKH,IAAM,GAAC,CAAAK,IAAA,QAAAC,IAClD,WAAc,OAAOH,KAAKa,KAAKjD,CAAG,GAAC,CAAAsC,IAAA,SAAAC,IACnC,WAAe,OAAOH,KAAKa,KAAKhD,CAAG,GAAC,CAAAqC,IAAA,SAAAY,MAEpC,SAAOC,GACH,IAAIC,EAAID,EAAEH,SAASZ,KAAKJ,QACxB,OAAO,IAAInB,EAAUuB,KAAKH,IAAIa,IAAIM,GAAIhB,KAAKF,IAAIY,IAAIM,GACvD,GAAC,CAAAd,IAAA,SAAAY,MAED,SAAOG,GAGH,OAAO,IAAIxC,EAFDC,EAAEC,MAAMjB,KAAKmC,IAAIG,KAAKI,KAAMa,EAAErD,GAAIF,KAAKmC,IAAIG,KAAKK,KAAMY,EAAEpD,IACxDa,EAAEC,MAAMjB,KAAKoC,IAAIE,KAAKM,KAAMW,EAAErD,GAAIF,KAAKoC,IAAIE,KAAKO,KAAMU,EAAEpD,IAEtE,GAAC,CAAAqC,IAAA,iBAAAY,MAED,WACI,IACII,EADIxD,KAAKyD,IAAInB,KAAKa,KAAKjD,EAAIoC,KAAKa,KAAKhD,GACxB,EACbgC,EAAMnB,EAAEC,MAAMqB,KAAKI,KAAMJ,KAAKK,MAC9BP,EAAMpB,EAAEC,MAAMqB,KAAKM,KAAMN,KAAKO,MAQlC,OAPIP,KAAKa,KAAKjD,EAAIoC,KAAKa,KAAKhD,GACxBgC,EAAIhC,GAAKqD,EACTpB,EAAIjC,GAAKqD,IAETrB,EAAIjC,GAAKsD,EACTpB,EAAIlC,GAAKsD,GAEN,IAAIzC,EAAUoB,EAAKC,EAC9B,GAAC,CAAAI,IAAA,gBAAAY,MAED,SAAcM,EAAG5D,EAAGC,GAChB,IACI4D,EADAL,EAAII,EAAEE,aAENN,EAAEpD,GAAK,GAAKoD,EAAEnD,GAAK,EACnBwD,EAAU,IAAI5C,EAAUC,EAAEC,MAAMqB,KAAKI,KAAMJ,KAAKK,MAAO3B,EAAEC,MAAMqB,KAAKI,KAAK5C,EAAGwC,KAAKK,KAAK5C,IAC/EuD,EAAEpD,EAAI,GAAKoD,EAAEnD,GAAK,EACzBwD,EAAU,IAAI5C,EAAUC,EAAEC,MAAMqB,KAAKM,KAAK9C,EAAGwC,KAAKK,MAAO3B,EAAEC,MAAMqB,KAAKM,KAAMN,KAAKK,KAAK5C,IAC/EuD,EAAEpD,EAAI,GAAKoD,EAAEnD,EAAI,EACxBwD,EAAU,IAAI5C,EAAUC,EAAEC,MAAMqB,KAAKM,KAAK9C,EAAGwC,KAAKO,KAAK9C,GAAIiB,EAAEC,MAAMqB,KAAKM,KAAMN,KAAKO,OAC5ES,EAAEpD,EAAI,GAAKoD,EAAEnD,EAAI,IACxBwD,EAAU,IAAI5C,EAAUC,EAAEC,MAAMqB,KAAKI,KAAMJ,KAAKO,KAAK9C,GAAIiB,EAAEC,MAAMqB,KAAKI,KAAK5C,EAAGwC,KAAKO,QAEvF,IAAItB,EAAeoC,EAAQpC,aAAamC,GAExC,OADAG,QAAQC,YAAwBtC,IAAjBD,EAA4B,8CACpC,CAACe,KAAKV,OAAO+B,EAAQpC,aAAamC,IAAKnC,EAClD,GAAC,CAAAiB,IAAA,MAAAY,MAED,SAAIG,GACA,OAAO,IAAIxC,EAAUuB,KAAKH,IAAIe,SAASlC,EAAEC,MAAMsC,EAAGA,IAAKjB,KAAKF,IAAIY,IAAIhC,EAAEC,MAAMsC,EAAEA,IAClF,GAAC,CAAAf,IAAA,QAAAY,MAED,SAAMW,GACF,OAAO,IAAIhD,EAAUuB,KAAKH,IAAI6B,WAAWD,GAAQzB,KAAKF,IAAI4B,WAAWD,GACzE,GAAC,CAAAvB,IAAA,gBAAAY,MAED,SAActD,EAAGC,GACb,OAAOuC,KAAKa,KAAKjD,GAAKJ,GAAKwC,KAAKa,KAAKhD,GAAKJ,CAC9C,GAAC,CAAAyC,IAAA,eAAAY,MAED,SAAaM,GAMT,IALA,IAAIO,EAAK,IAAIpC,EAAQS,KAAKQ,QAASR,KAAK4B,SAKxCC,EAAA,EAAAC,EADS,CAACH,EAHD,IAAIpC,EAAQS,KAAK4B,QAAS5B,KAAKS,SAC/B,IAAIlB,EAAQS,KAAKS,QAAST,KAAK+B,SAC/B,IAAIxC,EAAQS,KAAK+B,QAAS/B,KAAKQ,UAErBqB,EAAAC,EAAA1C,OAAAyC,IAAE,CAAhB,IAAIG,EAAIF,EAAAD,GACLZ,EAAIG,EAAEnC,aAAa+C,GAEvB,QAAU9C,IAAN+B,IAAqBA,EAAErD,GAAK+D,EAAGM,GAAGrE,GAAKqD,EAAEpD,GAAK8D,EAAGM,GAAGpE,GACpD,OAAOoD,CAEf,CAEJ,IAAC,CA7FiB,GAgGhB1B,EAAO,WAIR,OAAAU,GAHD,SAAAV,EAAY0C,EAAIC,GAAInC,OAAAR,GAChBS,KAAKiC,GAAKA,EACVjC,KAAKkC,GAAKA,CACd,GAAC,CAAA,CAAAhC,IAAA,eAAAC,IAED,WAAqB,OAAOH,KAAKkC,GAAGtB,SAASZ,KAAKiC,GAAK,GAAC,CAAA/B,IAAA,eAAAY,MAExD,SAAaqB,GAET,IAAIR,EAAK3B,KACLoC,EAAKT,EAAGM,GAAGrE,EAAGyE,EAAKV,EAAGM,GAAGpE,EAAGyE,EAAKX,EAAGO,GAAGtE,EAAG2E,EAAKZ,EAAGO,GAAGrE,EACrD2E,EAAKL,EAAGF,GAAGrE,EAAG6E,EAAKN,EAAGF,GAAGpE,EAAG6E,EAAKP,EAAGD,GAAGtE,EAAG+E,EAAKR,EAAGD,GAAGrE,EACrDmD,GAAKoB,EAAGE,IAAKG,EAAGE,IAAON,EAAGE,IAAKC,EAAGE,GAClCE,IAAMR,EAAGI,IAAKC,EAAGE,IAAON,EAAGI,IAAKD,EAAGE,IAAO1B,EAC1C6B,IAAMP,EAAGF,IAAKC,EAAGI,IAAOF,EAAGF,IAAKD,EAAGI,IAAOxB,EAC9C,GAAU,IAANA,GAAW4B,GAAK,GAAKA,GAAK,GAAKC,GAAK,GAAKA,GAAK,EAAG,CACjD,IAAIjF,EAAIwE,EAAKQ,GAAGN,EAAGF,GACfvE,EAAIwE,EAAKO,GAAGL,EAAGF,GACnB,OAAO3D,EAAEC,MAAMf,EAAGC,EACtB,CAGJ,GAAC,CAAAqC,IAAA,SAAAY,MAED,WACI,IAAIgC,EAAK9C,KAAKkC,GAAGtE,EAAIoC,KAAKiC,GAAGrE,EACzBmF,EAAK/C,KAAKkC,GAAGrE,EAAImC,KAAKiC,GAAGpE,EAC7B,OAAAH,KAAAsF,IAAQtF,KAAAsF,IAAAF,EAAI,GAACpF,KAAAsF,IAAGD,EAAI,GAAI,GAC5B,IAAC,CA7BQ,GC3Kb,IAYaE,EAAkB,QAClBC,EAAe,OACfC,EAAc,OAEvBC,EAAmC,CAACC,MAAO,QAASC,OAAQ,QAASC,WAAY,QAAS,UAAW,IAAKC,SAAU,QAASC,IAAK,MAAOC,KAAM,MAAO,kBAAmB,SAAU,cAAe,UAEtMhF,EAAEiF,QAAQC,SAAWlF,EAAEiF,QAAQrE,OAAO,CAClCuE,QAAS,CACLC,WAAY,KACZC,gBArBwB,EAsBxBC,WAAY,GACZC,YAAa,GACbC,aAAc,QAEdzC,MAAO,IACP0C,UAAW,EACXC,IAAK,IAILC,QAAS,KAGTC,eAAgB,UAChBC,kBAAkB,EAClBC,oBAAqB,IACrBC,YAAa,OACbC,gBAAiB,EACjBC,0BAA0B,EAC1BC,0BAA2BxB,EAC3ByB,sBAAuB,CACnBC,QAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,MAAO,OACPC,UAAW,OACXC,YAAa,IAEjBC,YAAa,GACbC,mBAAmB,EACnBC,oBAAoB,EACpBC,mBAAoB,CAChB/B,SAAU,eAEdgC,oBAAqB,CACjBhC,SAAU,UACViC,KAAM,iCAEVC,sBAAuB,CACnBC,QAAW,oBAEfC,oBAAqB,CAAC,gCAAiC,sBAAuB,yBAC9EC,UAAW,KAEXC,aAAc,KAEdC,OAAO,GAGXC,WAAY,SAAUC,EAAKpC,GACnBA,GACAnF,EAAEwH,WAAWlG,KAAM6D,GAGvB7D,KAAK6D,QAAQe,0BAA4BuB,OAAOC,OAAO,GAAIhD,EAAkCpD,KAAK6D,QAAQe,2BAE1G5E,KAAKqG,WAAarG,KAAK6D,QAAQa,iBAAmB,EAElD1E,KAAKsG,aAAe,GACpBtG,KAAKiG,IAAMA,EACXjG,KAAKuG,KAAO,KAEZvG,KAAKwG,YAAcxG,KAAKyG,YACxBzG,KAAK0G,iBAAmB,CACpB,CAACC,KAAM,WAAY7F,MAtFC,GAuFpB,CAAC6F,KAAM,YAAa7F,MAtFC,GAuFrB,CAAC6F,KAAM,OAAQ7F,MAtFC,IAwFpBd,KAAK4G,SAAW,CACZvD,MAAO,EACPC,OAAQ,GAGZtD,KAAK6G,OA3FO,EA4FZ7G,KAAK8G,cAAgB,KAErB9G,KAAK+G,aAAe,GAGpB/G,KAAKgH,UAAYtI,EAAEuI,aAEfjH,KAAK6D,QAAQkC,QACb/F,KAAKkH,eAAiBxI,EAAEuI,aACxBjH,KAAKkH,eAAeC,MAAMlB,GAC1BjG,KAAKoH,eAAiB,CAACtC,QAAQ,EAAMC,OAAQ,EAAGC,QAAS,GAAKC,MAAO,QAASC,UAAW,QAASC,YAAa,KAInHnF,KAAKqH,aAAeC,SAASC,cAAc,KAC3CpB,OAAOC,OAAOpG,KAAKqH,aAAaG,MAAO,CAACC,QAAW,SAGnDzH,KAAK0H,IAAMJ,SAASC,cAAc,SAClCvH,KAAK0H,IAAIC,UAAW,EAEpBL,SAASM,KAAKC,YAAY7H,KAAK0H,KAE/B1H,KAAK0H,IAAII,MAAMC,WAAW,yDAA0D,GAEpF/H,KAAKgI,YAAcV,SAASC,cAAc,OAC1CpB,OAAOC,OAAOpG,KAAKgI,YAAa,CAACC,UAAW,sBAC5C9B,OAAOC,OAAOpG,KAAKgI,YAAYR,MAAOxH,KAAK6D,QAAQe,0BAA0B,CAAC6C,QAAS,SACvFzH,KAAKiG,IAAIiC,WAAWC,OAAOnI,KAAKgI,aAEhChI,KAAKoI,SAASpI,KAAK6D,QAAQpC,OAC3BzB,KAAKqI,eAAerI,KAAK6D,QAAQY,aACjCzE,KAAKsI,oBAAoBtI,KAAK6D,QAAQgB,uBACtC7E,KAAKuI,cAAcvI,KAAK6D,QAAQC,YAChC9D,KAAKwI,mBAAmBxI,KAAK6D,QAAQE,iBACrC/D,KAAKyI,cAAczI,KAAK6D,QAAQG,YAChChE,KAAK0I,gBAAgB,IACrB1I,KAAK2I,aAAa3I,KAAK6D,QAAQM,UAClC,EAEDyE,QAAS,WACL5I,KAAK6I,mBACL7I,KAAKiG,IAAI6C,YAAY9I,KAAKgH,WAC1BhH,KAAKiG,IAAIiC,WAAWa,OAAO/I,KAAKgI,YACnC,EAEDvB,UAAW,WAKP,IAHA,IAAIuC,EAAa,GACbxL,EAAI,EACJC,EAAI,EACCwL,EAAI,EAAGA,GAAK,EAAGA,IACpBzL,EAAIE,KAAKwL,MAAM,IAAGxL,KAAAsF,IAAI,EAAIiG,EAAE,IAC5BxL,EAAIC,KAAKwL,MAAM,KAAIxL,KAAAsF,IAAG,EAAIiG,EAAE,IAC5BD,EAAWxK,KAAK,CAACmI,KAAIwC,IAAAA,OAAMF,GAAK5F,MAAO7F,EAAG8F,OAAQ7F,IAEtD,IAAK,IAAIwL,EAAI,EAAGA,GAAK,EAAGA,IACpBzL,EAAIE,KAAKwL,MAAM,IAAIxL,KAAAsF,IAAG,EAAIiG,EAAE,IAC5BxL,EAAIC,KAAKwL,MAAM,KAAIxL,KAAAsF,IAAG,EAAIiG,EAAE,IAC5BD,EAAWxK,KAAK,CAACmI,KAAIwC,IAAAA,OAAMF,GAAK5F,MAAO7F,EAAG8F,OAAQ7F,IAEtD,OAAOuL,CACV,EAODI,kBAAmB,WACf,IAAI5L,EAAIwC,KAAK4G,SAASvD,MAClB5F,EAAIuC,KAAK4G,SAAStD,OACtB,GAvKyB,IAuKrBtD,KAAK+D,gBAA8C,CACnD,IAAIsF,EAAO7L,EAAGA,EAAIC,EAAGA,EAAI4L,CAC7B,CACA,MAAO,CAAChG,MAAO7F,EAAG8F,OAAQ7F,EAC7B,EAOD6L,UAAW,SAAU7H,EAAO8H,EAAUC,GAClC,IAAIC,EAAK,CACLC,OAAQ,EACRC,OAAkB,MAATlI,EAAiBA,EAAQzB,KAAKyB,MACvC8H,SAAUA,EACVC,SAAUA,EACVI,SAAU5J,KAAKgE,WACf6F,QAAS7J,KAAK6D,QAAQI,YACtB6F,aAAc9J,KAAKuG,KAAKwD,YACxBC,wBAAyB,CAAE,EAC3BC,WAAY,CAAE,EACdC,WAAY,GAIZC,EAAe,GADAV,EAAGC,OAASD,EAAGE,QAE9BS,EAAWX,EAAGF,SAAWY,EACzBE,EAAWZ,EAAGD,SAAWW,EACzBG,EAAWb,EAAGG,SAAWO,EACzBI,EAAed,EAAGI,QAAUM,EAG5BK,EAAK,CACLC,IAAKzK,KAAK0K,eAAeN,EAAW,IAAMX,EAAGK,cAC7Ca,IAAK3K,KAAK0K,eAAeL,EAAW,IAAMZ,EAAGK,cAE7Cc,IAAK5K,KAAK0K,eAAeJ,EAAW,IAAMb,EAAGK,cAE7Ce,KAAM7K,KAAK0K,eAAeH,EAAe,IAAMd,EAAGK,cAClD1F,IAAK1G,KAAKoN,MAAM9K,KAAK+K,WAAWtB,EAAGE,UAkBvC,OAhBAF,EAAGO,wBAA0BQ,EAE7Bf,EAAGuB,YAAchL,KAAK6D,QAAQO,IAAMoG,EAAGpG,IAEvC+B,OAAOC,OAAOqD,EAAIzJ,KAAKiL,wBAAwBxB,EAAGuB,YAAaE,WAC/DzB,EAAGrF,IAAMqF,EAAGO,wBAAwB5F,IAAMqF,EAAG0B,kBAE7C1B,EAAGQ,WAAa,CACZQ,IAAK/M,KAAKwL,MAAMsB,EAAGC,IAAMhB,EAAG0B,mBAC5BR,IAAKjN,KAAKwL,MAAMsB,EAAGG,IAAMlB,EAAG0B,mBAE5BP,IAAKlN,KAAKwL,MAAMsB,EAAGI,IAAMnB,EAAG0B,mBAE5BN,KAAMnN,KAAKwL,MAAMsB,EAAGK,KAAOpB,EAAG0B,mBAC9B/G,IAAKqF,EAAGrF,KAELqF,CACV,EAED2B,+BAAgC,WAAyB,IAAfjH,EAASkH,UAAAjM,OAAA,QAAAF,IAAAmM,UAAA,GAAAA,UAAA,GAAG,EAElDlH,GAAa,EACb,IAAIyC,EAAW5G,KAAKoJ,oBAChBkC,EAAUtL,KAAKuG,gBAAgB7H,EAAE6M,aAAgBvL,KAAKuG,KAAOvG,KAAKuG,KAAKiF,YACvEC,EAAUzL,KAAKiG,IAAIyF,QAAQJ,EAAOK,gBAClCC,EAAc5L,KAAKiG,IAAIyF,QAAQJ,EAAOO,gBACtCC,EAAQF,EAAYhO,EAAI6N,EAAQ7N,EAChCmO,EAAQH,EAAY/N,EAAI4N,EAAQ5N,EAChC4L,EAAKzJ,KAAKsJ,UAAUtJ,KAAKyB,MAAOmF,EAASvD,MAAOuD,EAAStD,QAEzD0I,EAAiBtO,KAAKC,KAAK8L,EAAGC,OAAU1J,KAAKiM,eAAeH,EAAOrC,EAAGK,cAAiB,KAAQL,EAAGF,SAAyB,EAAdE,EAAGG,SAA4B,EAAbH,EAAGI,UAClIqC,EAAiBxO,KAAKC,KAAK8L,EAAGC,OAAU1J,KAAKiM,eAAeF,EAAOtC,EAAGK,cAAiB,KAAQL,EAAGD,SAAyB,EAAdC,EAAGG,SAA4B,EAAbH,EAAGI,UAClIsC,EAAgBzO,KAAKoC,IAAIkM,EAAgBE,GAE7C,GAAIlM,KAAK6D,QAAQkC,MAAO,CAEpB,IAAI/G,EAAO,CAACgB,KAAKiG,IAAImG,UAAUX,GAAUzL,KAAKiG,IAAImG,UAAUR,IAC5DlN,EAAE2N,UAAUrN,EAAMgB,KAAKoH,gBAAgBD,MAAMnH,KAAKkH,eACtD,CAEA,IAAIoF,EAAYtM,KAAKuM,4BAA4BvM,KAAKuG,MAClDiG,EAAmB,SAAU/K,GAC7B,OAAO,GAIX,GAAkB,IAAd0C,GAtPS,IAsPUmI,EACnB,OAAOH,EAxPE,IA0PTG,EACAE,EAAmB,SAAU/K,GACzB,IAAIgI,EAAKzJ,KAAKsJ,UAAU7H,EAAOmF,EAASvD,MAAOuD,EAAStD,QAAQ0G,wBAC2FhM,EAAAC,EAAxIZ,EAAoBoO,EAAQ7K,SAAS,CAAC6I,EAAGoB,KAAMpB,EAAGoB,OAAQe,EAAYlL,IAAI,CAAC+I,EAAGoB,KAAMpB,EAAGoB,OAAQpB,EAAGgB,IAAM,EAAIhB,EAAGmB,IAAKnB,EAAGkB,IAAM,EAAIlB,EAAGmB,KAAI,GAC3J,OADS5M,EAAA,GAAMA,EAAA,EAEnB,EAAEyO,KAAKzM,MA9PE,IA+PFsM,IACPE,EAAmB,SAAU/K,GACzB,IAAIgI,EAAKzJ,KAAKsJ,UAAU7H,EAAOmF,EAASvD,MAAOuD,EAAStD,QAAQ0G,wBAEhE,OADYhK,KAAK0M,oBAAoB1M,KAAKuG,KAAMkD,EAAGgB,IAAKhB,EAAGkB,IAAKlB,EAAGmB,IAAKnB,EAAGoB,KAAM7K,KAAK+D,iBACzE3E,MACjB,EAAEqN,KAAKzM,OAUX,IAJA,IAAI2M,EAAa,EACblL,EAAQ0K,EACRS,GAAQnL,EAAQ,EAChBoL,EAAY,EACTD,EAAO,IAAMA,GAAS,IAAI,CAC7B,IAAIE,GAAkB,EACtBH,IACA,IAAI5L,EAAIyL,EAAiB/K,GAgBzB,GAfIV,EAAIoD,EACJ2I,EAAmBF,EAAO,EACnB7L,EAAIoD,EACX2I,EAAmBF,EAAO,GAE1BC,EAAYpL,EACZmL,GAAyB,EAAlBlP,KAAKyD,IAAIyL,IAGhBE,IACAF,GAAQA,EAAO,GACfnL,EAAQmL,EAAO,IACfA,GAAc,GAElBnL,GAAgBmL,EACZD,EAAa,KAAc,IAAN5L,EAAS,CAC9BQ,QAAQwL,MAAM,2CACd,KACJ,CACJ,CAOA,OANIF,EAAY,IACZpL,EAAQoL,GACR7M,KAAK6D,QAAQkC,OACbxE,QAAQyL,IAAG,4BAAA7D,OAA6BwD,IAGrCjP,KAAKC,KAAK8D,EACpB,EAED8K,4BAA6B,SAAUU,GACnC,OAAKA,aAAmBvO,EAAE6M,cACrB0B,aAAmBvO,EAAEwO,SACrBD,aAAmBvO,EAAEyO,UAAYnN,KAAKoN,iBAAqC,GAAlBpN,KAAKmE,UAnTtD,EAqTD8I,aAAmBvO,EAAEyO,SApTpB,GAuTb5L,QAAQyL,IAAI,yBAzTI,EA2TnB,EAMDK,aAAc,WACV,IAAKrN,KAAKuG,KACN,OAAO,KAEX,GAAIvG,KAAKuG,gBAAgB7H,EAAEyO,WAAanN,KAAKuG,KAAK+G,KAE9C,OAAO,KAGPtN,KAAK6D,QAAQkC,OACb/F,KAAKkH,eAAeqG,cAGxB,IAAI9L,EAAQzB,KAAKyB,MACbzB,KAAKoN,kBACL3L,EAAQzB,KAAKoL,+BAA+BpL,KAAKmE,YAGrD,IAAIyC,EAAW5G,KAAKoJ,oBAChBK,EAAKzJ,KAAKsJ,UAAU7H,EAAOmF,EAASvD,MAAOuD,EAAStD,QAExDmG,EAAG+D,mBAAqB,GACxB/D,EAAG1L,MAAQ,GACX0L,EAAGgE,OAAS,GAEZ,IAAInB,EAAYtM,KAAKuM,4BAA4BvM,KAAKuG,MAClDmH,EA1VS,IA2VRpB,EAA8BtM,KAAK2N,kBAAkBlB,KAAKzM,MA1VlD,IA2VJsM,EAA8BtM,KAAK0M,oBAAoBD,KAAKzM,MAC7D,WAAa,MAAO,IAExB4N,EAAOnE,EAAGO,wBACdP,EAAG+D,mBAAqBE,EAAc1N,KAAKuG,KAAMqH,EAAKnD,IAAKmD,EAAKjD,IAAKiD,EAAKhD,IAAKgD,EAAK/C,KAAM7K,KAAK+D,iBAG/F,IAAK,IAAIzF,EAAI,EAAGA,EAAImL,EAAG+D,mBAAmBpO,OAAQd,IAAK,CACnD,IAAIuP,EAAUpE,EAAG+D,mBAAmBlP,GAAGuP,QACvCpE,EAAG+D,mBAAmBlP,GAAKmL,EAAG+D,mBAAmBlP,GAAGwP,IAAIF,EAAKhD,KAC7D,IAAImD,EAAatE,EAAG+D,mBAAmBlP,GAAGmD,MAAM,EAAEgI,EAAG0B,mBACrD1B,EAAG+D,mBAAmBlP,GAAGuP,QAAUA,EACnCE,EAAWF,QAAUA,EACrBpE,EAAG1L,MAAMS,KAAKuP,EAClB,CAMA,GAJAtE,EAAGtF,UAAYsF,EAAG1L,MAAMqB,OACxBqK,EAAG1C,aAAe,GAGd/G,KAAKgO,oBAAoB5O,OAAS,EAClC,IAAK,IAAI6B,EAAI,EAAGA,EAAIwI,EAAG1L,MAAMqB,OAAQ6B,IAC7BjB,KAAKgO,oBAAoBC,SAAShN,IAClCwI,EAAG1C,aAAavI,KAAKyC,QAG7B,IAAK,IAAIA,EAAI,EAAGA,EAAIwI,EAAG1L,MAAMqB,OAAQ6B,IACjCwI,EAAG1C,aAAavI,KAAKyC,GAK7B,OADAwI,EAAGyE,kBAAoBzE,EAAG1C,aAAa3H,OAChCqK,CACV,EAUD0E,WAAY,SAAUC,EAAcC,EAAWC,GAC3C,IAAKtO,KAAKuG,KACN,OAAO,KAEX,GAAIvG,KAAKuG,gBAAgB7H,EAAEyO,WAAanN,KAAKuG,KAAK+G,KAE9C,OAAO,KAGX,IAAIhC,EAAStL,KAAKuG,gBAAgB7H,EAAE6M,aAAevL,KAAKuG,KAAOvG,KAAKuG,KAAKiF,YAGrE+C,EAAW,IAAI9P,EAAUuB,KAAKiG,IAAIyF,QAAQJ,EAAOK,gBAAiB3L,KAAKiG,IAAIyF,QAAQJ,EAAOO,iBAG1Fb,EAAcoD,EAAe1Q,KAAKoC,IAAIyO,EAASlL,MAAOkL,EAASjL,QAC/DkL,EAAgBH,EAAYrD,EAGhCuD,EAAWA,EAAST,IAAIU,GAEpBF,IACAC,EAAWA,EAASD,kBAExB,IAAIvQ,EAAQD,EAAwByQ,EAASE,QAASF,EAASG,YAAaH,EAASlL,MAAOkL,EAASjL,QAEhF,IAAjBvF,EAAMqB,QAENmC,QAAQwL,MAAM,2DAGlB,IAAIvC,EAAK,CACLC,IAAK8D,EAASlL,MACdsH,IAAK4D,EAASjL,OACdqL,KAAMN,EAAYrD,GAIlB4D,EAAa,CACb5E,wBAAyBQ,EACzBQ,YAHJA,EAAcoD,EAAe1Q,KAAKoC,IAAI0K,EAAGC,IAAKD,EAAGG,KAI7CT,WAAY,EACZsD,mBAAoBzP,EACpBA,MAAO,IAGXoI,OAAOC,OAAOwI,EAAY5O,KAAKiL,wBAAwBD,IAGvD,IAAK,IAAI1M,EAAI,EAAGA,EAAIsQ,EAAWpB,mBAAmBpO,OAAQd,IACtDsQ,EAAW7Q,MAAMO,GAAKsQ,EAAWpB,mBAAmBlP,GAAGmD,MAAM,EAAEmN,EAAWzD,mBAc9E,OAXAyD,EAAW3E,WAAa,CACpBQ,IAAK/M,KAAKwL,MAAMsB,EAAGC,IAAMmE,EAAWzD,mBACpCR,IAAKjN,KAAKwL,MAAMsB,EAAGG,IAAMiE,EAAWzD,mBAIpCN,KAAMnN,KAAKwL,MAAMsB,EAAGK,KAAO+D,EAAWzD,oBAKnCyD,CACV,EAQD3D,wBAAyB,SAAUD,GAAgC,IAAnBF,EAAKO,UAAAjM,OAAAiM,QAAAnM,IAAAmM,UAAAnM,GAAAmM,UAAG3N,GAAAA,KAAKC,KAIrD0G,EAAWrE,KAAKqE,QACU,mBAAjBrE,KAAKqE,QAA0BrE,KAAKqE,UAAYrE,KAAKqE,QAC9DrE,KAAKiG,IAAI4I,aAET3E,EAAaxM,KAAKmC,IAClBwE,EACAyG,EAAM9K,KAAKiG,IAAI6I,aAAa9D,EAAahL,KAAKiG,IAAI8I,aAItD,MAAO,CAAC7E,WAAYA,EAAYiB,kBAFRnL,KAAKiG,IAAI+I,aAAahP,KAAKiG,IAAI8I,UAAW7E,GAGrE,EAMD+E,aAAc,SAAUC,GACpB,OAAkB,OAAdlP,KAAKuG,MA3eG,IA2ecvG,KAAK6G,QAC3BtF,QAAQwL,MAAM,4CACP,OAGLmC,IACFA,EAAYlP,KAAKqN,gBAEjB6B,EACAlP,KAAKmP,gBAAgBD,EAAU1B,mBAAoB0B,EAAUlF,wBAAwBY,KAErF5K,KAAK6I,mBAEFqG,EACV,EAODE,iBAAkB,SAAUC,GACxB,OAAkB,OAAdrP,KAAKuG,MAjgBG,IAigBcvG,KAAK6G,QAC3BtF,QAAQwL,MAAM,+BACP,MAGLsC,GAKNrP,KAAKmP,gBAAgBE,EAAU7B,mBAAoB6B,EAAUrF,wBAAwB2E,MAE9EU,QANHrP,KAAK6I,kBAOZ,EAKDA,iBAAkB,WACd7I,KAAKgH,UAAUuG,aAClB,EAMD+B,SAAU,WACNtP,KAAK8G,cAAgB,CACjBzD,MAAOrD,KAAKiG,IAAIsJ,eAAe/H,MAAMnE,MACrCC,OAAQtD,KAAKiG,IAAIsJ,eAAe/H,MAAMlE,OACtC3D,OAAQK,KAAKiG,IAAI8D,YACjByF,KAAMxP,KAAKiG,IAAI8I,UACfU,kBAAoBzP,KAAKgH,UAAUsG,KACnCoC,kBAAmB1P,KAAKiG,IAAIiC,WAAWyH,cAAcnI,MAAMoI,UAG/D5P,KAAKiG,IAAI6C,YAAY9I,KAAKgH,WACtBhH,KAAK6D,QAAQkC,OACb/F,KAAKkH,eAAeqG,cAEpBvN,KAAK6D,QAAQc,2BACbwB,OAAOC,OAAOpG,KAAKgI,YAAYR,MAAO,CAClCC,QAAS,OACTnE,OAAQuM,OAAOC,eAAexM,OAAO,MACrCD,MAAOwM,OAAOC,eAAezM,MAAM,MACnCG,SAAU,QACVC,IAAK,EACLC,KAAM,IAEV1D,KAAKiG,IAAIiC,WAAWyH,cAAcnI,MAAMoI,SAAW,UAEvD5P,KAAK+P,gBACL/P,KAAK0H,IAAIC,UAAW,CACvB,EAMDqI,YAAa,WACThQ,KAAKiG,IAAIsJ,eAAe/H,MAAMnE,MAAQrD,KAAK8G,cAAczD,MACzDrD,KAAKiG,IAAIsJ,eAAe/H,MAAMlE,OAAStD,KAAK8G,cAAcxD,OAC1DtD,KAAKiG,IAAIgK,QAAQjQ,KAAK8G,cAAcnH,OAAQK,KAAK8G,cAAc0I,KAAM,CAACU,SAAS,IAC3ElQ,KAAK8G,cAAc2I,iBACnBzP,KAAKiG,IAAIkK,SAASnQ,KAAKgH,WAE3BhH,KAAKiG,IAAIiC,WAAWyH,cAAcnI,MAAMoI,SAAW5P,KAAK8G,cAAc4I,kBACtE1P,KAAKiG,IAAImK,iBACTpQ,KAAKgI,YAAYR,MAAMC,QAAU,OAEjCzH,KAAKqQ,eACLrQ,KAAK0H,IAAIC,UAAW,EACpB3H,KAAK6G,OAzkBO,CA0kBf,EAMDkJ,cAAe,WAEX/P,KAAKiG,IAAIqK,QAAQC,UACjBvQ,KAAKiG,IAAIuK,gBAAgBD,UACzBvQ,KAAKiG,IAAIwK,SAASF,UAClBvQ,KAAKiG,IAAIyK,SAASH,UAClBvQ,KAAKiG,IAAI0K,gBAAgBJ,UACrBvQ,KAAKiG,IAAI2K,SAAS5Q,KAAKiG,IAAI2K,QAAQL,UACvCvQ,KAAKiG,IAAI4K,UAAUN,SACtB,EAMDF,aAAc,WAEVrQ,KAAKiG,IAAIqK,QAAQQ,SACjB9Q,KAAKiG,IAAIuK,gBAAgBM,SACzB9Q,KAAKiG,IAAIwK,SAASK,SAClB9Q,KAAKiG,IAAIyK,SAASI,SAClB9Q,KAAKiG,IAAI0K,gBAAgBG,SACrB9Q,KAAKiG,IAAI2K,SAAS5Q,KAAKiG,IAAI2K,QAAQE,SACvC9Q,KAAKiG,IAAI4K,UAAUC,QACtB,EAODC,UAAW,WACP,GAhnBY,IAgnBR/Q,KAAK6G,OACL,OAAO,EAGX,IAAImK,EAAYhR,KAAKqN,eAErB,IAAK2D,EACD,OAAO,EAEXhR,KAAK6G,OAxnBQ,EAynBb7G,KAAKiR,YAAYD,GACjBhR,KAAKsP,WACLhI,SAAS4J,iBAAiB,sBAAuBlR,KAAKmR,WAAW1E,KAAKzM,KAAMgR,GAAY,CAACI,MAAM,IAE/FpR,KAAKqR,cAAcL,EAAUjT,MAAOiT,EAAUjK,aAAciK,EAAU9G,WAAYlK,KAAKyE,YAC1F,EAWD6M,YAAa,SAAUlD,EAAcC,EAAWC,GAAiD,IAAjCiD,IAAwBlG,UAAAjM,OAAA,QAAAF,IAAAmM,UAAA,KAAAA,UAAA,GACpF,GA3oBY,IA2oBRrL,KAAK6G,OACL,OAAO,EAGX,IAAI2K,EAAS,SAAUC,GACnBzR,KAAKgQ,cACLhQ,KAAK0R,WAAWD,EACpB,EAAEhF,KAAKzM,MAEH4O,EAAa5O,KAAKmO,WAAWC,EAAcC,EAAWC,GAE1D,IAAKM,EACD,OAAO,EAEX,IAAI5P,EAAO4P,EAAW7Q,MAAM,GACxB4T,EAAcvD,EACdwD,EAAexD,EACbE,IACEtP,EAAKqE,OAASrE,EAAKsE,OACnBsO,EAAelU,KAAKoN,MAAM9L,EAAKsE,QAAUtE,EAAKqE,MAAQ+K,IAEtDuD,EAAcjU,KAAKoN,MAAM9L,EAAKqE,OAASrE,EAAKsE,OAAS8K,KAI7DpO,KAAK6G,OAnqBQ,EAoqBb7G,KAAKiR,YAAYrC,GACjB5O,KAAKsP,WAELhI,SAAS4J,iBAAiB,sBAAuB,SAAUW,GC7qB5D,IAAqBC,EAAWC,EAAUC,EAAWC,ED8qB1CJ,EAAKK,QAAYL,EAAKK,OAAOzE,QAAwC,IAA9BoE,EAAKK,OAAOzE,OAAOrO,OAI1DmS,GClrBUO,EDwrBAD,EAAKK,OAAOzE,OAAO,GCxrBRsE,EDwrBYJ,ECxrBFK,EDwrBeJ,ECxrBJK,EDwrBkB,SAASjS,KAAKyE,YCvrBjF,IAAI0N,SAAQ,SAACC,EAASC,GACzB,IAAMC,EAAShL,SAASC,cAAc,UAChCgL,EAAMD,EAAOE,WAAW,MAE9BF,EAAOjP,MAAQ0O,EACfO,EAAOhP,OAAS0O,EAEhBS,kBAAkBX,EAAW,CAACY,YAAaX,EAAUY,aAAcX,EAAWY,cAAe,SACxFC,MAAK,SAAAC,GACFP,EAAIQ,UAAUD,EAAa,EAAG,GAC9BV,EAAQE,EAAOU,UAAUf,EAAiB,IAC9C,IAAE,OAAQ,SAAUgB,GAChBZ,EAAOY,EACX,GACR,KDyqBqGJ,KAAK,SAAUK,GAChGlT,KAAKmT,eAAeD,EAA+B,SAArBlT,KAAKyE,YAAyB,MAAQzE,KAAKyE,aACzE+M,EAAO0B,IACTzG,KAAKzM,OACJ,OAAC,SAAUiT,GACd1R,QAAQwL,MAAMkG,GACdzB,GACJ,KAZAxR,KAAKmT,eAAetB,EAAKK,OAAOzE,OAAO,GAAyB,SAArBzN,KAAKyE,YAAyB,MAAQzE,KAAKyE,aACtF+M,EAAOK,EAAKK,OAAOzE,OAAO,KAL1B+D,GAkBR,EAAE/E,KAAKzM,MAAO,CAACoR,MAAM,IAErBpR,KAAKqR,cAAc,CAACrS,GAAO,KAAM4P,EAAW1E,WAAYqH,EAA2B,OAAQvR,KAAKyE,YAEnG,EAID2O,MAAO,WAnsBU,IAosBTpT,KAAK6G,SAGT7G,KAAK6G,OAtsBS,EAusBjB,EAQDsK,WAAUA,SAAC1H,EAAIoI,GAEX,IAAIpE,EAAUoE,EAAKK,OAAUL,EAAKK,OAAOzE,OAAS,GAC9CgE,EAAO,KACPD,EAAS,WACTxR,KAAKgQ,cACLhQ,KAAK0R,WAAWD,EACpB,EAAEhF,KAAKzM,MAEP,GAxtBc,IAwtBVA,KAAK6G,OAAT,CAKK4G,GAAUA,EAAOrO,SAAWqK,EAAGyE,oBAChC3M,QAAQyL,IAAI,8CACZwE,KA8BJ,IA1BA,IAAI6B,EAAU,SAAUC,EAAKxP,EAAYyP,GACrC,GAAKD,GAAQC,GAAeA,EAAW9N,MAA4B,KAApB8N,EAAW9N,MAAgB8N,EAAW/P,SAArF,CAEA,IAAIhG,EAAIsG,EAAW,GACfrG,EAAIqG,EAAW,GACf7C,EAAIsS,EAAW/P,SACfZ,EAAI2Q,EAAW9N,KACf+N,EAAK,EACLC,EAAK,EACLC,EAAO,CAAA,EACX,GAAU,YAANzS,EACAuS,EAAK,EAAKC,EAAK,EAAKC,EAAO,CAACC,MAAO,OAAQC,SAAU,YAClD,GAAU,aAAN3S,EACPuS,EAAKhW,EAAE,EAAGiW,EAAK,EAAKC,EAAO,CAACC,MAAO,QAASC,SAAU,YACnD,GAAU,eAAN3S,EACPuS,EAAK,EAAKC,EAAKhW,EAAE,EAAGiW,EAAO,CAACC,MAAO,OAAQC,SAAU,cAClD,IAAU,gBAAN3S,EAIP,YADAM,QAAQsS,KAAK,8BAFbL,EAAKhW,EAAE,EAAGiW,EAAKhW,EAAE,EAAGiW,EAAO,CAACC,MAAO,QAASC,SAAU,SAI1D,CACAN,EAAI7N,KAAK7C,EAAG4Q,EAAIC,EAAIC,EApBhB,GAuBJJ,EAAM,KACDhV,EAAI,EAAGA,EAAImL,EAAG1C,aAAa3H,OAAQd,IAAK,CAC7C,IAAIU,EAAOyK,EAAG1L,MAAM0L,EAAG1C,aAAazI,IACpC0B,KAAK8T,aAAa5Q,EAAc5E,EAAGmL,EAAG1C,aAAa3H,OAAQJ,GAC3D,IAAIxB,OAAC,EAAEC,OAAC,EAEJuB,EAAK6O,SACLrQ,EAAIiM,EAAGD,SACP/L,EAAIgM,EAAGF,WAEP/L,EAAIiM,EAAGF,SACP9L,EAAIgM,EAAGD,UAEX,IAAIuK,EAAcvW,EAAIC,EAAI,YAAc,WACxC,IACI,IAAIqG,EAAa,CAACtG,EAAGC,GACV,MAAP6V,IACAA,EAAM,IAAIU,MAAMC,MAAM,CAACC,OAAQpQ,EAAYiQ,YAAaA,EAAaI,UAAU,KAC3EC,YAAYpU,KAAK6D,QAAQuB,aACc,OAAvCpF,KAAK6D,QAAQ6B,uBAAkCS,OAAOkO,KAAKrU,KAAK6D,QAAQ6B,uBAAuBtG,OAAS,GACxGkU,EAAIgB,sBAAsBtU,KAAK6D,QAAQ6B,wBAG3C4N,EAAIiB,QAAQ,CAAC/W,EAAGC,GAAIsW,GAExBT,EAAIkB,SAAS/G,EAAOnP,GAAI0B,KAAKyE,YAAa,EAAG,EAAGjH,EAAGC,OAAGyB,EAAW,QACjEmU,EAAQC,EAAKxP,EAAY9D,KAAK6D,QAAQ2B,qBACtC6N,EAAQC,EAAKxP,EAAYqC,OAAOC,OAAO,CAACX,aAAI0D,OAAUM,EAAG1C,aAAazI,GAAG,EAAC6K,QAAAA,OAAOM,EAAGtF,YAAcnE,KAAK6D,QAAQ0B,qBAE3GvF,KAAK6D,QAAQgC,WAA+C,mBAA3B7F,KAAK6D,QAAQgC,WAC9C7F,KAAK6D,QAAQgC,UAAUyN,EAAK7J,EAAG1C,aAAazI,GAOnD,CAAC,MAAOmW,GACLlT,QAAQwL,MAAM0H,GACdzU,KAAK6G,OAnyBC,EAoyBN,KACJ,CACJ,CAtyBc,IAuyBV7G,KAAK6G,QAKT4K,EAAO6B,EAAIoB,OAAO,OAAQ,CAACC,SAAU3U,KAAK4U,YAAY5U,KAAK6D,QAAQS,eAAgB,SACnFtE,KAAKmT,eAAe1B,EAAM,OAC1BD,KANIA,GA7EJ,MAFIA,GAsFP,EAWDH,cAAe,SAAStT,EAAO8W,EAAS3K,EAAYzF,GAEhD,IAAIgJ,EAAS,GAEb,IAAKoH,EAAS,CACVA,EAAU,GACV,IAAK,IAAIvW,EAAI,EAAGA,EAAIP,EAAMqB,OAAQd,IAC9BuW,EAAQrW,KAAKF,EAErB,CACA,IAAIkT,EAAS,WACTlK,SAASwN,oBAAoB,0BAA2BC,GACxDzN,SAASwN,oBAAoB,qBAAsBE,GACnD1N,SAAS2N,cAAc,IAAIC,YAAY,sBAAuB,CAAChD,OAAQ,CAACzE,OAAQA,KACpF,EAAEhB,KAAKzM,MAGHmV,EAAS,SAAUC,GAEnB,GAAIA,EAAYC,QAAO,CAAA,IAC2BC,EAD3BC,EAAAC,EACLxV,KAAK6D,QAAQ+B,qBAAmB,IAA9C,IAAA2P,EAAAnU,MAAAkU,EAAAC,EAAAtM,KAAAwM,MAAgD,CAAA,IAAvCrU,EAACkU,EAAAxU,MACN,GAAIsU,EAAYC,QAAQjU,GACpB,OAAO,CACf,CAAC,CAAA,MAAAsU,GAAAH,EAAAd,EAAAiB,EAAA,CAAA,QAAAH,EAAAI,GAAA,CAAA,CACL,OAAI3V,KAAK6D,QAAQiC,cAAqD,mBAA9B9F,KAAK6D,QAAQiC,cAC1C9F,KAAK6D,QAAQiC,aAAasP,EAGzC,EAAE3I,KAAKzM,MAEH4V,EAAiB,WACjB,OAAO,IAAIzD,SAAS,SAACC,EAASC,GAC1BA,EAAO,oCACX,KAQgB,SAAhB5N,EACAmR,EAAiBC,WAAWC,OACL,QAAhBrR,EACPmR,EAAiBC,WAAWE,MACL,SAAhBtR,IACPmR,EAAiBC,WAAWG,QAGhC,IAAIjB,EAAgB,SAAUkB,GAC1B,IAAI3X,EAAI2X,EAAG/D,OAAO5T,EACd4X,EAAInY,EAAM8W,EAAQvW,IAElBmD,EAAQzB,KAAKqG,WACbxC,EAAU,CACVR,MAAO3F,KAAKoN,MAAMoL,EAAE7S,OAAS5B,EAC7B6B,OAAQ5F,KAAKoN,MAAMoL,EAAE5S,QAAU7B,EAC/B+F,MAAO,CACH2O,UAAW,SAAW1U,EAAQ,IAC9B2U,gBAAiB,YAErBjB,OAAQA,GAGZS,EAAe5V,KAAKiG,IAAIsJ,eAAgB1L,GACnCgP,KAAK,SAAUhB,GA33BV,IA43BE7R,KAAK6G,QAKLpF,EAAQ,GAAKoQ,aAAgBwE,KAC7BC,gBAAczE,EAAM7R,KAAKsG,aAAetG,KAAKqG,YAAYwM,MAAK,SAAUhB,GACpEpE,EAAOjP,KAAKqT,GACZvK,SAAS2N,cAAc,IAAIC,YAAY,qBAAsB,CAAChD,OAAQ,CAAC5T,EAAEA,EAAE,KAC/E,IACOmD,EAAQ,IACfoQ,EAAO0E,EAAgBA,iBAAC1E,EAAM7R,KAAKsG,aAAetG,KAAKqG,aAE3DoH,EAAOjP,KAAKqT,GACZvK,SAAS2N,cAAc,IAAIC,YAAY,qBAAsB,CAAChD,OAAQ,CAAC5T,EAAEA,EAAE,OAbvEkT,KAcN/E,KAAKzM,OACD,MAAC,SAAUiT,GACb1R,QAAQwL,MAAM,sCAAuCkG,GACrDjT,KAAKwW,YAAY,kBACjBxW,KAAK6G,OA/4BH,EAg5BF2K,GACJ,EAAE/E,KAAKzM,MACf,EAAEyM,KAAKzM,MAEHgV,EAA4B,SAASiB,GACrC,IACI,IAAI3X,EAAI2X,EAAG/D,OAAO5T,EACd2C,EAAI4T,EAAQvW,GAEhB,GAAIA,IAAMuW,EAAQzV,QAz5BZ,IAy5BsBY,KAAK6G,OAE7B,YADA2K,IAIJ,IAAIiF,GAAY,IAAIC,MAAOC,UACvBT,EAAInY,EAAMkD,GACdjB,KAAK8T,aAAa7Q,EAAiB3E,EAAGuW,EAAQzV,OAAQ8W,GACtD,IAAI1Y,EAAI0Y,EAAE7S,MACN5F,EAAIyY,EAAE5S,OACNsT,EAAaV,EAAEtW,OAGnB,GAAII,KAAKiG,IAAI8I,YAAc7E,EAAY,CACnC,IAAIiB,EAAoBnL,KAAKiG,IAAI+I,aAAahP,KAAKiG,IAAI8I,UAAW7E,GAElE0M,EADiBV,EAAEzU,MAAM0J,GACDvL,MAC5B,CACAgX,EAAa5W,KAAKiG,IAAImG,UAAUwK,GAEhC5W,KAAKiG,IAAIsJ,eAAe/H,MAAMnE,MAAK8F,GAAAA,OAAMzL,KAAKC,KAAKH,GAAM,MACzDwC,KAAKiG,IAAIsJ,eAAe/H,MAAMlE,OAAM6F,GAAAA,OAAMzL,KAAKC,KAAKF,GAAM,MAC1DuC,KAAKiG,IAAImK,iBACTpQ,KAAKiG,IAAIgK,QAAQ2G,EAAY1M,EAAY,CAACgG,SAAS,IAMnD,IAAI2G,EAAQC,YAAY,WACpB,GAv7BE,IAu7BE9W,KAAK6G,OAGL,OAFAkQ,cAAcF,QACdrF,IAGJ,IAAyEwF,EAAA/Y,EAA3B+B,KAAKiX,aAAajX,KAAKiG,KAAI,GAApEiR,EAAUF,EAAA,GAAEG,EAAWH,EAAA,GAAEI,EAAYJ,EAAA,GAK1C,GAJIhX,KAAK6D,QAAQkC,OACbxE,QAAQyL,IAAG,iBAAA7D,OAAkBgO,EAAW,UAAAhO,OAAS+N,IAErDlX,KAAK8T,aAAa3Q,EAAagU,EAAaD,EAAY,MACpDA,IAAeC,EAGf,OAFAJ,cAAcF,QACdvP,SAAS2N,cAAc,IAAIC,YAAY,0BAA2B,CAAChD,OAAQ,CAAC5T,EAAEA,OAG9E,IAAIoY,MAAOC,UAAYF,EAAYzW,KAAK6D,QAAQW,sBAC5CxE,KAAK6D,QAAQkC,OACbxE,QAAQyL,IAAG7D,sDAAAA,OAAuDiO,EAAaC,OAEnFrX,KAAK6G,OA18BP,EA28BE7G,KAAKwW,YAAY,UAAWY,GAC5BL,cAAcF,GACdrF,IAEP,EAAC/E,KAAKzM,MAAO,IACjB,CAAC,MAAOyU,GACLlT,QAAQwL,MAAM,uCAAwC0H,GACtDzU,KAAKwW,YAAY,kBACjBhF,GACJ,CACJ,EAAE/E,KAAKzM,MAEPsH,SAAS4J,iBAAiB,0BAA2B6D,GACrDzN,SAAS4J,iBAAiB,qBAAsB8D,GAChD1N,SAAS2N,cAAc,IAAIC,YAAY,qBAAsB,CAAChD,OAAQ,CAAC5T,EAAE,KAC5E,EASD2Y,aAAc,SAAShR,GACnB,IAAIiR,EAAa,EACbC,EAAc,EACdG,EAAoB,KACxB,IAAK,IAAIzY,KAAKoH,EAAIsR,QAAS,CACvB,IAAIC,EAAQvR,EAAIsR,QAAQ1Y,IACpB2Y,EAAMH,MAAQG,EAAMC,WAChBD,EAAME,SACNR,GAAcM,EAAME,OAAOC,GAAGC,WAAWxY,OACzC+X,GAAeK,EAAME,OAAOC,GAAGE,iBAAiB,2BAA2BzY,QAE3EoY,EAAMM,UAAkC,OAAtBR,IAClBA,EAAoBE,GAGhC,CAIA,OAHKF,IACDH,EAAcD,GAEX,CAACA,EAAYC,EAAaG,EACpC,EAEDS,UAAW,SAAUpR,EAAMkL,GACvB7R,KAAKiG,IAAI+R,KAAK,YAAarR,EAAMkL,EACpC,EAEDZ,YAAa,SAAUY,GACnB7R,KAAK+X,UAAU,QAASlG,EAC3B,EAEDH,WAAY,SAAUD,GAClBzR,KAAK+X,UAAU,SAAU,CAACtG,KAAMA,GACnC,EAEDqC,aAAc,SAAUmE,EAAWC,EAAQC,EAAYC,GACnDpY,KAAK+X,UAAU,WAAY,CAACE,UAAWA,EAAWC,OAAQA,EAAQC,WAAYA,EAAYC,KAAMA,GACnG,EAED5B,YAAa,SAAU6B,EAAQxG,GAC3B7R,KAAK+X,UAAU,UAAW,CAACM,OAAQA,EAAQxG,KAAMA,GACpD,EAIDyG,gBAAiB,WACb,IAAIC,OAASrZ,EAMb,OALAc,KAAKiG,IAAIuS,WAAU,SAAShB,QACTtY,IAAXqZ,GAAwBf,EAAMiB,mBAC9BF,EAASf,EAAMiB,iBAAiBC,QAAQ,WAAY,IAE5D,IACOH,CACV,EAEDtM,eAAgB,SAAS0M,EAAQC,GAE7B,IAAIC,EAAS7Y,KAAKiG,IAAI6S,mBAAmBF,GAAKlY,IAAIhC,EAAEC,OAAOga,EAAO,EAAG,IACjEI,EAAS/Y,KAAKiG,IAAI6S,mBAAmBF,GAAKlY,IAAIhC,EAAEC,OAAOga,EAAO,EAAG,IAGrE,OAFAE,EAAS7Y,KAAKiG,IAAI+S,mBAAmBH,GACrCE,EAAS/Y,KAAKiG,IAAI+S,mBAAmBD,GAC9BF,EAAOI,WAAWF,EAC5B,EAEDrO,eAAgB,SAASwO,EAAQN,GAC7B,OAAOM,EAASlZ,KAAKiM,eAAe,EAAG2M,EAC1C,EAED7N,WAAY,SAAStJ,GACjB,IACIkI,EAASlI,EAETZ,EAAOb,KAAKoJ,oBACZG,EAAW1I,EAAKwC,MAChBmG,EAAW3I,EAAKyC,OAEhB6G,EAAe,GAPN,EAMeR,GAExBS,EAAWb,EAAWY,EACtBE,EAAWb,EAAWW,EAEtBgP,EAAcnZ,KAAKuG,KAAKwD,YAO5B,OANe/J,KAAK0K,eAAeN,EAAW,IAAM+O,IAG7B5P,EAAW,MAFnBvJ,KAAK0K,eAAeL,EAAW,IAAM8O,IAG7B3P,EAAW,OACR,CAE7B,EAED4P,WAAY,SAAShV,GACjB,IAAIvD,EAAOb,KAAKoJ,oBACZG,EAAW1I,EAAKwC,MAChBmG,EAAW3I,EAAKyC,OAChB+V,EAAWjV,EAAM,KAAOmF,EACxB+P,EAAY9P,EAAWD,EAAY8P,EAIvC,OAHc,EAAIrZ,KAAKiM,eAAeoN,EAAUrZ,KAAKuG,KAAKwD,aAAe,IAAOR,EAClE,EAAIvJ,KAAKiM,eAAeqN,EAAUtZ,KAAKuG,KAAKwD,aAAe,IAAOP,GAC7C,CAEtC,EAED2F,gBAAiB,SAAUpR,EAAOkD,GAC9BjB,KAAKgH,UAAUuG,cACf,IAAK,IAAIjP,EAAI,EAAGA,EAAIP,EAAMqB,OAAQd,IAAK,CACnC,IAAIib,EAAUxb,EAAMO,GAChBkb,EAAYD,EAAQzL,KAAK7M,GAE7BuY,EAAY,CAACxZ,KAAKiG,IAAImG,UAAUoN,EAAU3Z,KAAMG,KAAKiG,IAAImG,UAAUoN,EAAU1Z,MAC7EyZ,EAAU,CAACvZ,KAAKiG,IAAImG,UAAUmN,EAAQ1Z,KAAMG,KAAKiG,IAAImG,UAAUmN,EAAQzZ,MAEvEpB,EAAE2N,UAAUkN,EACRpT,OAAOC,OAAO,CAAE,EAAEpG,KAAKyZ,mBAAmBtS,MAAMnH,KAAKgH,WAEzDtI,EAAE2N,UAAUmN,EACRrT,OAAOC,OAAO,CAAE,EAAEpG,KAAKyZ,iBAAkB,CAACC,MAAM,KAASvS,MAAMnH,KAAKgH,UAC5E,CAC2B,MAAvBhH,KAAKgH,UAAUsG,MACftN,KAAKgH,UAAUG,MAAMnH,KAAKiG,IAEjC,EAED0H,kBAAmB,SAAUV,EAASzP,EAAGC,EAAGwD,EAAGgD,EAAa0V,GACxD,GAAgB,OAAZ1M,EACA,MAAO,GAEX,IAAI3B,EAAS,KAQb,OANK2B,aAAmBvO,EAAE6M,eACtBD,EAAS2B,GAEoB,mBAArBA,EAAQzB,YAChBF,EAAS2B,EAAQzB,aAEhBF,EAMSxN,EAHAkC,KAAKiG,IAAIyF,QAAQJ,EAAOK,gBAAgB/K,SAAS,CAACqD,EAAYA,IAC1DjE,KAAKiG,IAAIyF,QAAQJ,EAAOO,gBAAgBnL,IAAI,CAACuD,EAAYA,IAEfzG,EAAE,EAAEyD,EAAGxD,EAAE,EAAEwD,GAL5D,EAQd,EAEDyL,oBAAqB,SAASO,EAASzP,EAAGC,EAAGwD,EAAG2Y,EAAID,GAChD,GAAgB,OAAZ1M,GAAkD,mBAAvBA,EAAQ4M,WACnC,MAAO,GAEX,IAAIC,EAAK7M,EAAQ4M,aAEjB,GAAkB,IAAdC,EAAG1a,OACH,MAAO,GAGP0a,EAAG,aAAcC,QAGjBD,EAAKA,EAAG,IAGZ,IADA,IAAIjb,EAAIib,EAAGE,QACF1b,EAAI,EAAGA,EAAIO,EAAEO,OAAQd,IAC1BO,EAAEP,GAAK0B,KAAKiG,IAAIyF,QAAQ7M,EAAEP,IAE9B,IAAA2b,ED/mCD,SAAiCpb,EAAGrB,EAAGC,EAAGyc,GAI7C,IAHA,IAAInc,EAAQ,GACRoc,EAAgB,GAChBrb,EAAK,IACI,CACT,IAAwEsb,EAAAnc,EAAnCW,EAAuBC,EAAGrB,EAAGC,EAAGqB,GAAG,GAAnEE,EAAIob,EAAA,GAAEC,EAAED,EAAA,GAAEnb,EAAYmb,EAAA,GAAEjb,EAAIib,EAAA,GACjC,GAAIF,EAAK,CACL,IAAgFI,EAAArc,EAAnCW,EAAuBC,EAAGpB,EAAGD,EAAGsB,GAAG,GAA3Eyb,EAAMD,EAAA,GAAEE,EAAIF,EAAA,GAAEG,EAAcH,EAAA,GAAEI,EAAMJ,EAAA,GACzCtb,EAAK6O,SAAU,EACX6M,EAASvb,IACFkb,EAAmCG,EAA/Bvb,EAAqCwb,EAAvBtb,EAAuCub,GAA/D1b,EAAiCub,GAC7B1M,SAAU,EAEvB,CAEA,GADA9P,EAAMS,KAAKQ,QACUE,IAAjBD,EACA,MAEJkb,EAAc3b,KAAKS,GACnBJ,EAAE8b,OAAON,EAAI,EAAGpb,GAChBH,EAAKub,CACT,CACA,MAAO,CAACtc,EAAOoc,EACnB,CCwlCuCS,CAAwB/b,EAAGrB,EAAE,EAAEyD,EAAGxD,EAAE,EAAEwD,EA1oCjD,IA0oCoD0Y,GAA0BS,EAAAnc,EAAAgc,EAAA,GAA3Flc,EAAKqc,EAAA,GAAED,EAAaC,EAAA,GAG3B,GAAIpa,KAAK6D,QAAQkC,MAAO,CAEpB,IAAK,IAAIzH,EAAI,EAAGA,EAAI6b,EAAc/a,OAAQd,IACtC6b,EAAc7b,GAAK0B,KAAKiG,IAAImG,UAAU+N,EAAc7b,IACvD,IAE4Buc,EAF5BC,EAAAtF,EAEe2E,GAAa,IAA7B,IAAAW,EAAA1Z,MAAAyZ,EAAAC,EAAA7R,KAAAwM,MAA+B,CAAA,IAApBxU,EAAC4Z,EAAA/Z,MACRpC,EAAEqc,aAAa9Z,EAAG,CAAC+Z,OAAQ,EAAGlW,QAAQ,EAAOG,MAAO,QAASD,QAAS,EAAGG,YAAa,IAAMgC,MAAMnH,KAAKkH,eAC3G,CAAC,CAAA,MAAAwO,GAAAoF,EAAArG,EAAAiB,EAAA,CAAA,QAAAoF,EAAAnF,GAAA,CACL,CAEA,OAAO5X,CACV,EAED6W,YAAWA,SAACD,EAAUsG,GAIlB,IAHA,IACI3c,EACAmW,EACJyG,EAAA,EAAAC,EAHW,CAAC,MAAO,MAAO,OAGZD,EAAAC,EAAA/b,OAAA8b,IAAE,CACZ,IAAIE,EAAS,KADZ3G,EAAC0G,EAAAD,IAGF,IAAW,KADX5c,EAAIqW,EAAS0G,YAAYD,IACX,CACV,GAAI9c,IAAMqW,EAASvV,OAASgc,EAAOhc,OAC/B,MAEAd,GAAK,CAEb,CACJ,CAEA,OAAW,IAAPA,EACImW,IAAMwG,EACCtG,EAEAA,EAAS2G,UAAU,EAAGhd,GAAK,IAAM2c,EAGzCtG,EAAW,IAAMsG,CAC3B,EAED9H,eAAcA,SAACtB,EAAMoJ,GACjB,GAAMjb,KAAK6D,QAAQU,kBAAsBsN,EAAzC,CAIA,IAAI0J,EAAWvb,KAAK4U,YAAY5U,KAAK6D,QAAQS,eAAgB2W,GAE7D9U,OAAOC,OAAOpG,KAAKqH,aAAc,CAACmU,SAAYD,IAC9Cvb,KAAKqH,aAAaoU,KAAQ5J,aAAgBwE,KAAQqF,IAAIC,gBAAgB9J,GAAQA,EAC9E7R,KAAKqH,aAAauU,OAPd,CAQP,EAEDC,cAAa,WACT,MAAqC,UAA9B7b,KAAK6D,QAAQK,YACvB,EAEDkJ,cAAa,WACT,MAAqC,UAA9BpN,KAAK6D,QAAQK,YACvB,EAQD4X,WAAY,SAAUC,GAClB/b,KAAKqE,QAAU0X,CAClB,EAEDC,QAAS,SAAUzV,GACf,GAAoB,WAAhB0V,EAAO1V,MACAA,aAAgB7H,EAAE6M,eAA2C,mBAAnBhF,EAAKiF,UAClD,MAAM,IAAI0Q,MAAM,oFAGxBlc,KAAKuG,KAAOA,EACPA,GACDvG,KAAK6I,kBAEZ,EAEDT,SAAU,SAAS3G,GACfzB,KAAKyB,MAAQyJ,SAASzJ,EACzB,EAED0a,SAAU,WACN,OAAOnc,KAAKyB,KACf,EAODkH,aAAc,WAAqB,IAAXyT,EAAK/Q,UAAAjM,OAAA,QAAAF,IAAAmM,UAAA,GAAAA,UAAA,GAAG,EAChB,EAAR+Q,GAAc,IACdA,EAAQ,GACZpc,KAAKmE,UAAYiY,CACpB,EAMDC,aAAc,WACV,OAAOrc,KAAKmE,SACf,EAKDqE,mBAAoB,SAAUuL,GAAa,IACJuI,EADIC,EAAA/G,EACzBxV,KAAK0G,kBAAgB,IAAnC,IAAA6V,EAAAnb,MAAAkb,EAAAC,EAAAtT,KAAAwM,MAAqC,CAAA,IAA5BkE,EAAC2C,EAAAxb,MACN,GAAuC,mBAA5BiT,EAAYyI,aACnB7C,EAAEhT,KAAK6V,gBAAkBzI,EAAYyI,cAErC,YADAxc,KAAK+D,gBAAkB4V,EAAE7Y,OAG7B,GAAI6Y,EAAE7Y,QAAUiT,EAEZ,YADA/T,KAAK+D,gBAAkBgQ,EAG/B,CACA,CAAA,MAAA2B,GAAA6G,EAAA9H,EAAAiB,EAAA,CAAA,QAAA6G,EAAA5G,GAAA,CACA3V,KAAK+D,gBAAkB/D,KAAK6D,QAAQE,eACvC,EAMD0E,cAAe,SAAUgU,GACrBzc,KAAKgE,WAAakH,SAASuR,EAC9B,EAEDC,cAAe,WACX,OAAO1c,KAAKgE,UACf,EAMD0E,gBAAiB,SAAUiU,GACK,WAAxBV,EAAOU,GACP3c,KAAKgO,oBAAsB,GAE3BhO,KAAKgO,oBAAsB2O,EAAa3C,OAE/C,EAMDzR,cAAe,SAAU5B,GAAM,IAAAiW,EAAA5c,KACvB1B,EAAI0B,KAAKwG,YAAYqW,WAAU,SAAAhc,GAAI,OAAIA,EAAK8F,OAASA,MAC9C,IAAPrI,IACAA,EAAI0B,KAAKwG,YAAYqW,WAAU,SAAAhc,GAAI,OAAIA,EAAK8F,OAASiW,EAAK/Y,QAAQC,eAEtE9D,KAAK8D,WAAa9D,KAAKwG,YAAYlI,GACnC0B,KAAK4G,SAASvD,MAAQrD,KAAK8D,WAAWT,MACtCrD,KAAK4G,SAAStD,OAAStD,KAAK8D,WAAWR,MAC1C,EAEDwZ,YAAa,SAAUzZ,EAAOC,GACrBD,EAAQ,GAAOC,EAAS,IACzBtD,KAAK4G,SAASvD,MAAQ6H,SAAS7H,GAC/BrD,KAAK4G,SAAStD,OAAS4H,SAAS5H,GAChCtD,KAAK8D,WAAa,KAEzB,EAEDiZ,eAAgB,WACd,OAAO/c,KAAKwG,WACb,EAEDwW,cAAe,WACX,OAAOhd,KAAK8D,UACf,EAEDmZ,oBAAqB,WACjB,OAAOjd,KAAK0G,gBACf,EAED2B,eAAgB,SAAS6L,GACrB,GAAc,QAAVA,GAA8B,OAAVA,EACpB,KAAA/K,0BAAAA,OAAgC+K,EAAM,KAE1ClU,KAAKyE,YAAcyP,CACtB,EAED5L,oBAAqB,SAAUd,GACtBA,IACDA,EAAQxH,KAAK6D,QAAQgB,uBAEzB7E,KAAKyZ,iBAAmBtT,OAAOC,OAAO,CAAE,EAAEoB,EAC9C,IASJ9I,EAAEwe,SAAW,SAAUjX,EAAKpC,GACxB,OAAO,IAAInF,EAAEiF,QAAQC,SAASqC,EAAKpC,EACvC"}